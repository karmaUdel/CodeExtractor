U6EAT2Z37 : I guess it might be my development style - I make very tiny little changes, and recompile at every step.
U153UK3FA : I just wrap operator application in parentheses
U6EAT2Z37 : cool :slightly_smiling_face:
U14Q8S4EM : Also theres the infix package in Haskell
U14Q8S4EM : Which reveals `&lt;&lt;`, `&lt;|` and the like
U6EAT2Z37 : reveals? We already have `&lt;&lt;` and `&lt;|` but they're named different things.
U23SA861Y : &lt;$&gt; and map literally have the same number of key strokes
U17R26VR8 : i've got a string "abc:123" and a type `type ID = ID String Int` and i'd like to decode the former into the latter
U17R26VR8 : using the pipeline, ```
JDP.optional "id" idDecoder (ID "" 0)
```

U17R26VR8 : what should idDecoder be
U17R26VR8 : i'm thinking:```
JDP.optional "id" (JD.string &gt;&gt; idDecoder) (ID "" 0)

idDecoder: String -&gt; JD.Decode ID
```

U153UK3FA : <@U17R26VR8> it’s a <http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#string> mapped to become a `Decoder ID`
U153UK3FA : <http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#map>
U17R26VR8 : ah... map, yes ok :+2:
U17R26VR8 : :two_thumbs_up:
U17R26VR8 : :emote_fail:
U17R26VR8 : but thank you
U6EAT2Z37 : @fonf `&lt;$&gt;` is `fmap`. One is an infix operator, the other a prefix function, but they're literally the same function. They're good for different things, and they're both more general than `map` from `List`
U153UK3FA : my most ‘fun’ haskell operator adventure was finding an operator in a code example, I couldn’t find it in any of the imported libraries, looked it up on hoogle but none of those were it, I think I eventually found out it was in a language extension.
U14Q8S4EM : <@U6EAT2Z37>, I mean theres a package that has the `&lt;&lt;` and `&lt;|` operators
U14Q8S4EM : It exposes them.
U14Q8S4EM : And `&gt;&gt;` and `|&gt;` etc
U14Q8S4EM : I dont have a lot of Haskell experience. Their functionality it at least that of `$` and `.`, but maybe something else too, not sure.
U14Q8S4EM : Either way, the way I think of it, is that Elm is a subset of Haskell.
U0CL0AS3V : eh, Elm is its own thing. Nonstrict evaluation is at the heart of Haskell, and Elm is strict. Among ML families they're close in that they share syntax and the concept of managed side effects, but otherwise Elm is probably closer to Standard ML than Haskell. :smile: 
U14Q8S4EM : Ah, okay. Yeah Ive never used Standard ML
U6EAT2Z37 : <@U0CL0AS3V> you think Elm is very different to Haskell? That's pretty interesting.
U6EAT2Z37 : <@U153UK3FA> interestingly, there are two hoogles :slightly_smiling_face: sometimes I wish Elm had a hoogle, like how purescript does
U153UK3FA : <@U6EAT2Z37> Elm has <http://klaftertief.github.io/elm-search/>
U6EAT2Z37 : Yeah, I think I saw that a while back. It's not very easy to find tho
U6EAT2Z37 : I guess I can just google for "elm search" so that works :slightly_smiling_face: :+1:
U0CK8CJ5D : <@U6EAT2Z37> The “Fancy Search” link in the resources section on <http://package.elm-lang.org> links to it.
U6EAT2Z37 : TIL :slightly_smiling_face: Wouldn't have known that! :slightly_smiling_face: thanks
U3SJEDR96 : <@U6EAT2Z37> Different evaluation semantics and a different focus for the language means you end up with fairly different languages. They might look similar and there is a lot of conceptual overlap - they are, after, all, statically typed purely functional languages with similar syntax. Defining their relationship directly in terms of one another, though, is probably not very helpful. When it comes to language and library design, Elm is not (strictly) guided by Haskell, so defining one as a subset of the other is misguided at best.
U3SJEDR96 : People have tried to use Elm as "haskell for the web", and I don't think that has ever been a particularly nice experience
U3SJEDR96 : (aside: very nice to see you in here, I'm really enjoying your book!)
U6EAT2Z37 : <@U3SJEDR96> Yeah, sure, they're different. Obviously. But they're **extremely** similar in many core ways. As you mention, algebraic data types, pure functions, lambda calculus base. I think there are more similarities than not. No one's trying to define Elm in terms of Haskell or vice versa. :slightly_smiling_face: It's just nice to compare them, when they're similar. Trying to compare JS and Elm would be... misguided... and understanding Haskell's managed effects gives a really nice insight into Elm's... (because Elm purposefully hides this away, mostly). I find it very fascinating, in general. Learning Haskell would *definitely* improve one's Elm, for example.
U6EAT2Z37 : Yeah, I agree - purescript is more "Haskell for the web" :slightly_smiling_face: tho it's interestingly inbetween, too :slightly_smiling_face: (it's eager for a start... and uses `Eff` rather than a stack of effects, which is also interesting - tho Haskell has that, too, but it's not as popular)
U6EAT2Z37 : Thanks for the book-compliment. I'd like to write one for Elm sometime
U3SJEDR96 : Very true! And of course, recognizing parallels and conceptual overlap deepens understanding. But recognizing the differences is harder than recognizing the similarities, especially for one who is new to either language; and therein lies a danger, too :slightly_smiling_face:
U6EAT2Z37 : I realise there's a decided push towards "a language is a culture" in the Elm community. I'm not entirely sure I agree with that, but that's fine too :slightly_smiling_face:
U6EAT2Z37 : <@U3SJEDR96> oh my gosh yes... I mean, that's one of the biggest reasons people coming from imperative langs find pure FP lambda calculus langs so difficult - they assume it's "execute every line from the top to the bottom" semantics... when it's not, it's "evaluate from this point out" semantics :slightly_smiling_face:
U3SJEDR96 : I think what _irks_ me about relating Elm and Haskell in public discussion is perhaps simply that learning a new language works best when _not_ trying to understand one in terms of another. The issue being that defining one in terms of another probably leads to trying to understand one in terms of the other.
U3SJEDR96 : Does that make sense?
U6EAT2Z37 : Yeah it makes sense. I don't think I agree, though.
U6EAT2Z37 : I think it's important to use what you have to learn faster than you could without it.
U6EAT2Z37 : **use** imperative to understand functional, just don't use functional imperatively! :slightly_smiling_face:
U6EAT2Z37 : *use* your understanding of OOP to see what pure FP is like... but don't try to do OOP in pure FP... :slightly_smiling_face:
U3SJEDR96 : It's a short term benefit; but it also means you have to unlearn some misguided inferred knowledge after a while.
U6EAT2Z37 : the beauty of doing that is you start to understand more about the OOP you thought you understood and then realise "hey I didn't understand it as well as I thought" and you get a better grip of both :slightly_smiling_face:
U6EAT2Z37 : I'm after non-confusion :slightly_smiling_face:
U6EAT2Z37 : But yeah, comparison is not so useful... perhaps. Tho, lately I've been learning vim... and I don't have great answers to the semantic questions I had answers to in my existing editor... so that sucks a bit - that kind of comparison is *very* useful, I think.
U3SJEDR96 : I think that this type of drawing parallels and recognizing the massive conceptuals overlaps, is easier after you've grokked at least the basics of a language. Or at least, that has been my experience spending a ton of time in <#C192T0Q1E|beginners>. And I suppose learning is not a universal process :slightly_smiling_face:
U6EAT2Z37 : Definitely.
U5S1LBR7Y : Is there a preferred way to do set styles in elm?Do we use classes and css files?

U5S1LBR7Y : I want my styles to be scoped, is there a way to do it?
U1AP08WV6 : <@U6EAT2Z37> Forgive me my ignorance, but which book is it?
U3SJEDR96 : there are.. a few options.- plain old inline styles
- using `elm-css` (which has `namescapes` so you can do scoping, too ;)
- using plain old classes and external css
- using style-elements (which is basically a different paradigm)
- using an existing framework in elm, like `elm-bootstrap` or `elm-tachyons`

U5S1LBR7Y : Thanks. I will take a look
U5S1LBR7Y : elm-css looks good. Scoping is my main issue
U5S1LBR7Y : By style-elements do you mean similar to styled-components in react?
U3SJEDR96 : No, not really
U3SJEDR96 : <https://www.youtube.com/watch?v=NYb2GDWMIm0>
U6EAT2Z37 : <@U1AP08WV6> <http://happylearnhaskelltutorial.com|happylearnhaskelltutorial.com> - no need to apologise :slightly_smiling_face:
U0GR72XH8 : <@U0EUHKVGB> hi! We were thinking in Gizra about creating an elm-all-set implementation (`type EverySet t = EveryDict t ())`) -- Just making sure it wasn't already done
U6EAT2Z37 : There's an AllDict
U6EAT2Z37 : But that's not what you mean is it? <http://package.elm-lang.org/packages/eeue56/elm-all-dict/2.0.1>
U6EAT2Z37 : Sets are not Dicts, so I'm guessing not.
U0GR72XH8 : <@U6EAT2Z37> yeah I know -- I mean build and `EverySet` on top of it (`EveryDict` to `Dict` is what `EverySet` is to `Set`)
U3SJEDR96 : `type Set a = Set (Dict a ())` tho :slightly_smiling_face: (well, in Elm)
U0GR72XH8 : and yeah, Set in Elm is a Dict where key and value are the same
U6EAT2Z37 : Isn't that really... inefficient / not so elegant?
U0GR72XH8 : <@U6EAT2Z37> great presentation about it by Robin -- <https://www.youtube.com/watch?v=mmiNobpx7eI>
U3SJEDR96 : <@U6EAT2Z37> it's not optimal; but neither is maintaining two rb-tree impementations ¯\_(?)_/¯
U0EUHKVGB : There was an old package for 0.15 which did that. However, the author stopped being active in Elm
U1AP08WV6 : Thank you :slightly_smiling_face:
U3SJEDR96 : <@U0GR72XH8> "where the value is `()`" rather, but let's chalk it up to a typo :slightly_smiling_face:
U6EAT2Z37 : Didn't realise we'd switched to tries already. Always depends :slightly_smiling_face:
U0GR72XH8 : Yeah, there's no _typo_ safety in chats :wink:
U3SJEDR96 : Dict in Elm is just a red-black tree (although alternative implementations exist). Sets are Dicts "without" values. You get a constant memory overhead for every entry in a set, that way, but it's not _that_ bad, and hardly a problem in reality.
U6EAT2Z37 : Be nicer if the RB tree was somehow exposed maybe? All good. Probably not possible.
U3SJEDR96 : Can't easily expose the constructors for pattern-matching without making it possible to build unbalanced trees, so the added complexity seems to outweigh the (limited) use that would have. People haven't  asked about breadth first traversal, so I doubt it would be of much practical use
U6EAT2Z37 : Thank *you*!
U37HUSJ4R : does anyone have a link to Evans elm europe talk?
U2AHAPQUV : <@U37HUSJ4R> seems like it hasn’t been released yet, I saw somewhere that they’re close to putting in online
U37HUSJ4R : :smile: <@U2AHAPQUV>  thanks sir
U5WS7CJLV : any of you ever had trouble with WebSocket?
U5WS7CJLV : seems like one of my Elm web sockets is just not noticing messages
U5WS7CJLV : I have 3 of them
U5WS7CJLV : 2 always get the messages
U5WS7CJLV : the other one is a mystery - I can configure things so it will see messages, but normally it misses them
U5WS7CJLV : and when I say "configure things", I mean "changing stuff on the server side"
U5WS7CJLV : it is totally irrational to me why it sometimes works and sometimes doesn't
U5WS7CJLV : and so, mine is a general question about known issues with WebSocket
U5WS7CJLV : I have tried setting up an identical socket in the javascript console of my browser and it sees the messages just fine
U5WS7CJLV : I believe I've solved the mystery
U5WS7CJLV : WebSocket.listen takes a string (the url) and a String -&gt; msg function
U5WS7CJLV : and my String -&gt; msg function was never returning a message
U5WS7CJLV : Elm exploded in the course of trying to decode the socket data.  Or such is my best guess.
U5WS7CJLV : if I just swap my decoding logic with a Result.Err, then I can see the socket messages getting processed
U5S1LBR7Y : Is the type of List defined in elm-core? Or is it a compiler thing? I am looking at the List source here <https://github.com/elm-lang/core/blob/5.1.1/src/List.elm>.
The functions are using the type List. Where does that type come from?

U5WS7CJLV : you will probably have better luck on the beginners channel
U5WS7CJLV : here in general I seem to be monologue-ing to myself
U6EAT2Z37 : <@U5S1LBR7Y> :eyes:
U5S1LBR7Y : <@U6EAT2Z37> Did I miss something?
U6EAT2Z37 : Probably Native.List
U6EAT2Z37 : No, that meant I was looking :slightly_smiling_face:
U5S1LBR7Y : Okay
U5S1LBR7Y : Not in Native.List
U5S1LBR7Y : I mean it needs to be exposed if that was the case!
U6EAT2Z37 : I *think* this is where list literals are defined: <https://github.com/elm-lang/elm-compiler/blob/master/src/Parse/Expression.hs#L81>
U6EAT2Z37 : at least, the parsing of them
U0F01KLV6 : <@U5S1LBR7Y>: it's a compiler thing
U5S1LBR7Y : Ohh Okay :thumbsup:
U0F01KLV6 : But it's essentially equal to:type List a = Cons a (List a) | Empty

U0F01KLV6 : You can check out my elm europe talk for more details in the implementation, if you're interested
U5S1LBR7Y : Sure, I will. Thanks
U0F01KLV6 : :blush:
U5S1LBR7Y : Also I am having a hard time understanding union types
U5S1LBR7Y : Now I understand how it works
U5S1LBR7Y : Mainly what I dont understand is where are the types inside the union types defined?
U0F01KLV6 : Not following :/
U5S1LBR7Y : For eg: `type Maybe a = Nothing | Just a`
U6EAT2Z37 : <@U0F01KLV6> I couldn't seem to see any implementation details in your talk
U5S1LBR7Y : where is Nothing and Just defined
U5S1LBR7Y : They are not strings so they need to be defined somewhere right?
U6EAT2Z37 : <@U5S1LBR7Y> so that means `Maybe a` is a new type. It's defined as ... one of `Nothing` (as a data value constructor) or a data constructor value/function called `Just a` where a is some value of the same type as the `a` in `Maybe a`.
U0F01KLV6 : <@U6EAT2Z37> bad language, i ment explinaton on how they work "under the hood"
U6EAT2Z37 : <@U5S1LBR7Y> do you understand what I just said?
U6EAT2Z37 : <@U0F01KLV6> yeah, similarly. There was explanation of Linked List... maybe I didn't watch the correct talk. Didn't seem to be how it was actually implemented though.
U5S1LBR7Y : <@U6EAT2Z37> So it is indeed defining three types?
U5S1LBR7Y : `Maybe`, `Just` and `Nothing`?
U6EAT2Z37 : <@U5S1LBR7Y> nope... just one type. the things on the right are the value constructors
U6EAT2Z37 : a value constructor is a value or function that can build one of the values of that types
U6EAT2Z37 : So... `type OneOrTwo = One | Two` can have exactly one of two different values.
U6EAT2Z37 : `One : OneOrTwo` or `Two : OneOrTwo` &lt;- they're both values, but I've put the type on the end of them.
U6EAT2Z37 : does that make sense?
U0F01KLV6 : <@U5S1LBR7Y>: one way to look at this, is that integers are essentially: type Int = 1 | 2 | 3 | 4... 
U0F01KLV6 : 1 and 2 are values of the type Int
U5S1LBR7Y : Ohh I get it now!
U6EAT2Z37 : Yay :slightly_smiling_face:
U5S1LBR7Y : Thanks <@U0F01KLV6> and <@U6EAT2Z37>
U0F01KLV6 : No problem
U5S1LBR7Y : But if I create Such union types I will have to expose those value constructors as well right?
U5S1LBR7Y : how would I do that?
U0F01KLV6 : You don't have to, no, but you can
U5S1LBR7Y : I am guessing `module Foo exposing (OneOrTwo, One, Two)`
U6EAT2Z37 : `exposing (OneOrTwo(..))`
U6EAT2Z37 : You might hear "opaque types" bandied about. That's when you *don't* expose the "constructors".
U6EAT2Z37 : It's often a good pattern to *not* expose them, but rather expose a function from the module. That way you can keep the implementation of the type private to the function, and it defines a very tight interface for your module.
U6EAT2Z37 : So if you need to build a string value out of your `OneOrTwo` type, you could provide `toString : OneOrTwo -&gt; String`
U6EAT2Z37 : Then you've decoupled your internals from your externals, and you're free to refactor the internals however you see fit, whenever you like. (It's a *lot* easier to refactor this way, I think)
U5S1LBR7Y : Okay! Makes Sense :simple_smile:
U5S1LBR7Y : Thanks
U5S1LBR7Y : Its using the same syntax as module exposing?Just to understand, If I want to expose only `One`, i could write it like this: `exposing ( OneOrTwo(One) )`

U5S1LBR7Y : Is that correct?
U6EAT2Z37 : Try it out. :slightly_smiling_face: You'll have your answer :slightly_smiling_face:
U6EAT2Z37 : <http://ellie-app.com|ellie-app.com>
U5S1LBR7Y : Okay :laughing:
U6EAT2Z37 : <https://ellie-app.com/3RBpDqTfrNDa1/0>
U5S1LBR7Y : Can you have multiple files in ellie-app?Cant find that option!

U6EAT2Z37 : I don't know if you can.
U5S1LBR7Y : I tried it locally!
U5S1LBR7Y : It works as I thought, Now I get it!
U5S1LBR7Y : Thank you for your time <@U6EAT2Z37>
U0F7JPK36 : just one file. i don't plan on adding a multiple files option, that's not really what ellie is for
U42FYKFRN : hello - anyone know of a way to speed up elm compile times - currently it’s taking around 5 minutes which is pretty painful - I a stack of Mains and some common code - and then I elm-make all the mains and output the js for my app
U42FYKFRN : I have about 500 modules and a few thousand elm files (including elm-stuff)
U42FYKFRN : when the project was smaller compilation was fast - but now if I make a change to a common elm file which is used a lot - then it takes ages - and even if I make a change to a non common one - it still takes a lot longer than I would like
U0J1M0F32 : I think the main piece of advice is going to look for ways to cut down how many modules you're using and break up any very long case statements.
U0J1M0F32 : iirc, lots of small modules and very large case statements are especially rough on the compiler.
U42FYKFRN : hmm - if I change the implementation of a function without changing the signature of the function - then do the callers of the function need to be recompiled? I think it should only need to be “relinked”
U4872964V : I think it’s the “linking” that takes time actually
U42FYKFRN : really?
U42FYKFRN : how come linking takes that long?
U4872964V : Well, that i cannot answer :slightly_smiling_face:
U42FYKFRN : is there anyway to implement compilation fire walls ?
U4872964V : but it’s a lot of files to merge together
U42FYKFRN : this compilation time is crippling!
U4872964V : indeed, 0.19 is supposed to make compilation faster though
U4872964V : 500 modules sounds like a lot, i have like 20 modules or so, but then I put a lot in each file
U0J1M0F32 : Yah, the 0.19 speed bump should help, but I worry the 500+ modules is still going to be an issue if it continues to grow at that rate.
U0J1M0F32 : Whats the average LOC per file?
U42FYKFRN : well using third party elm libs can bump up the number of modules as well
U0J1M0F32 : I don't know if those are counted/treated the same as local modules.
U0J1M0F32 : I don't know enough about the compiler to say either way confidently.
U42FYKFRN : hmm
U42FYKFRN : apparently the averge LOC is about 100
U0RPQMZ9S : if you have any case statements with lots of possible cases, like `case (bigUnionType, anotherBigUnionType)`, those can especially slow down compilation
U42FYKFRN : well don’t have too many of those really in the core code - not sure about 3rd party modules we use though
U0RPQMZ9S : just rewriting them like so can give you a speed up```case bigUnionType of 
         FirstOne -&gt; 
             case anotherBigUnionType of 
                ...
```

U0RPQMZ9S : might be worth a shot
U0RPQMZ9S : this is one of the bugs slated to be fixed in 0.19
U42FYKFRN : when is 0.19 due out?
U0RPQMZ9S : No official timeline, my gut says between 1 and 2 months
U42FYKFRN : is it likely to have much impact on existing code?
U0J1M0F32 : No way of saying for sure, but I would imagine there will be a noticeable improvement.
U42FYKFRN : taking a speed increase but having to re-write large amounts of code might be just as painful in the short term
U0J1M0F32 : I also imagine it won't be a game changing speed increase.
U0J1M0F32 : Idk, I have personally found elm code bases fairly straightforward to refactor.


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
