U5QJW0DDE : this does not compile, but can you match for different types in Tex?
U4F64AKQV : As far as I know, it does not work that way.
U5QJW0DDE : so you'd have to specify what type of Tex the function fort accepts? i.e. `fort: Text Int -&gt; Int`
U4F64AKQV : Yes, you always need to specify something. It can be an explicit type like `Int` or it could be another type variable like `a`. The thing is that you can't really tailor the implementation based on that type variable as far as I'm aware. The type variable there is meant to provide a layer of generalization for when you want the same operation to be applicable for all types.
U4F64AKQV : I would recommend making separate functions if you need different behavior for different types.
U5QJW0DDE : ok
U39DE7RQ9 : <@U663M2MB7> yes it does. You can decode what ever structure
U5QJW0DDE : it's rather interesting to me that you can use variables in Elm code before they are actually defined
U663M2MB7 : <@U39DE7RQ9> do I attach a separate decoder for the objects in the list below the top element or is there something else here? reading the docs does not really make this clear to me
U39DE7RQ9 : scav: yes I can show you an example, w8
U39DE7RQ9 : ```
module Form.FormDecoder exposing (..)

import Form.Models exposing (..)
import Json.Decode exposing (int, string, nullable, Decoder, list, andThen, succeed)
import Json.Decode.Pipeline exposing (decode, required, optional)


decodeForm : Json.Decode.Value -&gt; Result String JsonForm
decodeForm modelJson =
    Json.Decode.decodeValue formDecoder modelJson


decodeFormList : Decoder (List JsonForm)
decodeFormList =
    list formDecoder


formDecoder : Decoder JsonForm
formDecoder =
    decode JsonForm
        |&gt; required "eventId" int
        |&gt; required "eventName" string
        |&gt; required "orgName" string
        |&gt; required "formName" string
        |&gt; required "formSteps" (list formStepDecoder)


formStepDecoder : Decoder FormStep
formStepDecoder =
    decode FormStep
        |&gt; required "stepId" string
        |&gt; required "stepTitle" string
        |&gt; required "stepIndex" int
        |&gt; required "questions" (list questionDecoder)


questionDecoder : Decoder Question
questionDecoder =
    decode Question
        -- Nödvändigt?
        |&gt; required "questionId" string
        |&gt; required "questionText" string
        |&gt; required "questionType" (string |&gt; andThen questionTypeDecoder)
        |&gt; required "questionIndex" int
        |&gt; optional "choices" (list choiceDecoder) []


questionTypeDecoder : String -&gt; Decoder QuestionType
questionTypeDecoder typeString =
    case typeString of
        "TextType" -&gt;
            Json.Decode.succeed TextType

        "TextType_email" -&gt;
            Json.Decode.succeed TextType_email

        "ChoiceType" -&gt;
            Json.Decode.succeed ChoiceType

        "InfoType" -&gt;
            Json.Decode.succeed InfoType

        _ -&gt;
            Json.Decode.succeed NoType


choiceDecoder : Decoder Choice
choiceDecoder =
    decode Choice
        |&gt; required "choiceFee" int
        |&gt; required "choiceIndex" int
        |&gt; required "choiceText" string
```

U39DE7RQ9 : The json:
U663M2MB7 : Oh, that makes sense
U663M2MB7 : `|&gt; required "formSteps" (list formStepDecoder)``
U39DE7RQ9 : ```"forms" : {
    "-Kh8yFc6pVkosSrUgDkD" : {
      "eventId" : 1,
      "eventName" : "Utmaningen 2017",
      "formName" : "AnmÃ¤lan till Utmaningen 2017",
      "formSteps" : [ {
        "questions" : [ {
          "questionId" : "martinwefwef",
          "questionIndex" : 1,
          "questionText" : "Namn",
          "questionType" : "TextType"
        }, {
          "questionId" : "martintrt54",
          "questionIndex" : 2,
          "questionText" : "E-post",
          "questionType" : "TextType_email"
        } ],
        "stepId" : "martin_step_ffeef",
        "stepIndex" : 1,
        "stepTitle" : "Kontaktinformation"
      }, {
        "questions" : [ {
          "questionId" : "martinefwegrh",
          "questionIndex" : 1,
          "questionText" : "Lagnamn",
          "questionType" : "TextType"
        }, {
          "choices" : [ {
            "choiceFee" : 0,
            "choiceIndex" : 1,
            "choiceText" : "Herr"
          }, {
            "choiceFee" : 0,
            "choiceIndex" : 2,
            "choiceText" : "Dam"
          }, {
            "choiceFee" : 0,
            "choiceIndex" : 3,
            "choiceText" : "Mix"
          } ],
          "questionId" : "martinfg43g43",
          "questionIndex" : 2,
          "questionText" : "Klass",
          "questionType" : "ChoiceType"
        }, {
          "choices" : [ {
            "choiceFee" : 800,
            "choiceIndex" : 1,
            "choiceText" : "LÃ¥ng"
          }, {
            "choiceFee" : 600,
            "choiceIndex" : 2,
            "choiceText" : "Kort"
          } ],
          "questionId" : "martinfwevweg",
          "questionIndex" : 3,
          "questionText" : "Bana",
          "questionType" : "ChoiceType"
        } ],
        "stepId" : "martin_step_ffee",
        "stepIndex" : 2,
        "stepTitle" : "TÃ¤vlingsinformation"
      } ],
      "orgName" : "Karlstad Multisport"
    }
```

U39DE7RQ9 : yes, does it make sense?
U5QJW0DDE : as far as I can tell, the single source of model data in the architecture is via the view function. I'm curious about the best way to handle a scenario where a distanct child html component needs some data in the model that none of its ancestors need. assuming these components are built as different functions, this would mean sending that data for a distanct child down through all its parents?
U663M2MB7 : totally :slightly_smiling_face:
U5QJW0DDE : or, just passing the entire model to all the children?
U663M2MB7 : Thanks!
U4JT89FGB : logically an ancestor needs said data if some descendant needs it. no need for entire model, just what is necessary for all descendants, eh?
U5QJW0DDE : that's not entirely correct. for example, re-frame (a clojurescript library) gets around this by separating subscriptions for a component from the location at which they are called/instantiated. a component independently establishes what it wants from the central model, without ancestors needing to know what a child needs.
U5QJW0DDE : an ancestor might only need to know that it needs to build a particular screen, for example, without caring what widgets should be on that screen and what those individual widgets need
U4JT89FGB : So your parent doens't know even which widgets are on it?


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
