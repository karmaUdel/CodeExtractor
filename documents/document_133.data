U3JURM9B6 : <@U06B8J0AJ>: have you used Haskell? the haskell solution to this would be the 'state' monad, then an external sequence_
U06B8J0AJ : <@U3JURM9B6> Unfortunately I haven't used it beyond the tutorial on the home page (which is quite nice)
U06B8J0AJ : `map` does seem to be easier to visualize than `reduce` though. I think `map` corresponds more to everyday patterns of life. You can imagine walking along a row of potted plants and watering each for example, getting a row of watered plants.
U06B8J0AJ : But what would be the `reduce` version of that? Repot them in one large pot, one plant at a time?
U06B8J0AJ : But also, the order in which they were repotted would somehow matter. I don't know, it's not _as_ straightforward.
U66SFLTPT : <@U3JURM9B6> in Haskell how would you solve the problem?
U66SFLTPT : `foldr` over a sequence?
U66SFLTPT : (I'm just curious)
U3JURM9B6 : <@U66SFLTPT> : I would write the code "imperatively" with putState / getState, then  put it on a do block + use sequence_ if there's a list
U050MP39D : I find it easier to go `write using loop/recur` -&gt; `refactor to reduce`
U3JURM9B6 : the point is that the code goes something like:```
s &lt;- getState
... do some processing ...
putState s'
```

but then the reduce somehow causes me to "invert" the state manipulation

U050MP39D : generally, than doseq. because that way you just delete a bunch of code and change some keywords. refactoring doseq and atom updates is annoying
U3JURM9B6 : <@U050MP39D> : loop/recur is definitely closer to reduce than doseq/atom
U3JURM9B6 : nevertheless, it seems that in an otherwise clean language, there's this mismatch between "mental thought" and "how code has to be written"
U3JURM9B6 : or maybe I just haven't mastered reduce idioms
U050MP39D : mmmmmm my assumption is that that mismatch is just a result of spending so much time in imperative languages. I definitely find myself having to go through that interim step a lot less than I did 4 years ago when I moved ruby-&gt;clojure. could be wrong though
U3JURM9B6 : haskell is not exactly '
U3JURM9B6 : imperative' -- some would say it's even more 'functional' :slightly_smiling_face:
U06B8J0AJ : <@U3JURM9B6> Is there no notion of `reduce` in Haskell though?
U051SS2EU : that's foldl
U050MP39D : there is, and it would be considered *way* more idiomatic than using the state monad
U3JURM9B6 : haskell definitely has foldl / foldr, but it also has state monads + sequence_
U051SS2EU : and it's provable that everything you can do via state manipulation you can do in a left fold / reduce, it's just a different code pattern to do it
U3JURM9B6 : I would say, any time you're bashing state, state monad is more idiomatic than folds
U3JURM9B6 : and with reduce, the initial value is basically your 'local state'
U050MP39D : the state monad is a "purely functional statically typed" math trick around writing an imperative looking thing and still keeping it pure
U3JURM9B6 : yeah, I guess 99% of the problems I have with clojure is: it doesn't have haskell's type system :slightly_smiling_face:
U050MP39D : funny, that's my favourite thing about clojure :laughing:
U051SS2EU : <@U3JURM9B6> frege is haskell for the jvm, and it would even be usable except it is too hard to use interfaces or extend java types (because it really does implement haskell's type system - which is better but also alien to the platform)
U3JURM9B6 : I tried using frege once; I found neither the documentation nor the community helpful.
U051SS2EU : I would have totally used it for some things in my codebase but not being able to define or implement interfaces (not to mention concrete inheritence, which clojure taught me how to do without), it was a no go
U1KK3BW3W : Is there a way that others are using tools like `eastwood` with files that contain namespaced keywords?
U051SS2EU : <@U3JURM9B6> I think their assumption is "just do it the way you would in haskell"
U050MP39D : thing is clojure just has no need for a state monad, because if imperative code is what's appropriate there *are* mutable options
U06B8J0AJ : Well, cognitively, our problem solving is very pattern based. A problem occurs-&gt;go fetch the nearest solution from memory that approximately fits problem-&gt;apply to problem. Certain mismatch is bound to happen when encountering a somewhat different paradigm.
U06B8J0AJ : Personally, I find macros to be some of the most intractable marshlands of the language. The parser in my head doesn't predict the output of a macro well at all.
U04V70XH6 : <@U051SS2EU> I really liked the promise of Frege and spent quite a bit of time working with it -- I wrote a Leiningen plugin for it and put out some mixed Clojure / Frege code examples. But, ultimately, I just found it too frustrating to use and kept going back to Clojure... which kinda fits in with the love/hate relationship I've had with Haskell ever since it appeared (I always hoped Haskell would rule the world but it seemed like the team behind it tried very hard to make sure that didn't happen!).
U051SS2EU : yeah I think I might have first heard of frege from you - and if I could have just defined / implemented interfaces I could have used it for my project…
U04V70XH6 : I just watched Prof Turner's talk about "Some History of Functional Programming Languages" from the Poland FP conference this year. Great to hear how everything came together (he was going to be my external examiner for my PhD thesis back in '86... if I'd actually completed it!).
U04V70XH6 : We used Miranda at my university and I was familiar with ML and SASL and a bunch of the other FP languages that all merged into Haskell. I created my own (SURE), just like all the other FP researchers in England at the time! :slightly_smiling_face:
U5ZAJ15P0 : Whereabout did you study?
U051SS2EU : I remember checking out CLEAN shortly after I got into software (by reading "tech yourself C++ in 21 days")
U051SS2EU : in retrospect I'm amazed I got turned to such an interesting direction so early on
U04V70XH6 : <https://www.youtube.com/watch?v=QVwm9jlBTik&amp;__s=csfyzpydsvfikkqz5bvw> (for those who missed the link in Eric's <http://PurelyFunctional.tv|PurelyFunctional.tv> newsletter)
U04V70XH6 : University of Surrey (Guildford).
U04V70XH6 : SURE was Surrey University Recursive Evaluator :slightly_smiling_face:
U5ZAJ15P0 : ooh, makes sense!
U5ZAJ15P0 : Hi! I have the following in a Datalog query:```
'[:find ... :where [(wef-backend.app.identity/past-expiry? ?expiry)]]]
```

U5ZAJ15P0 : Due to how Datomic/Datalog works I must fully qualify the past-expiry? function, even though it is available in the namespace where I wrote this query
U5ZAJ15P0 : is there some clever trick that would let me omit the full qualifier?
U5ZAJ15P0 : I tried syntax quoting on the query but that doesn't work, as it fully qualifies the `?expiry, etc` variables too
U5ZAJ15P0 : Essentially I would like to fully qualify some symbols in that quoted expression
U5ZAJ15P0 : but not others
U2H58V4P2 : I don't recall any problems with namespaced keywords, but I seem to remember I had problems with namespaced maps. As these were limited to my test classes, I added these namespaces to the ignore list I think. Also, I think there were some fixes on the master branch that remain unreleased. A bit vague I realise, but if you're still stuck tomorrow (unlikely) then I'll check when I'm back in front of a computer...
U051SS2EU : <@U5ZAJ15P0> you can use ` for this, and selectively use ~ for the symbols you want to namespace qualify
U5ZAJ15P0 : <@U051SS2EU> how so? I tried variations on your suggestion but didn't manage to get it to work
U051SS2EU : ```peregrine.circle=&gt; `[:find ... :where [identity ~'?foo]][:find ... :where [clojure.core/identity ?foo]]```



in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
