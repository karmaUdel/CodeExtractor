(false 1)```
<@U04V70XH6> I took it to mean they wanted to filter out both nil and false (which (filter identity ...) does)
So `some?` should work.
no, some? passes false through
just use identity if that's the semantics you want
Right, use `some?` if you only want to filter `nil` but keep `false`.
"support false" sounded like you wanted to allow it through and `identity` wasn't doing that for you...
`(filter identity coll)` works perfectly fine. :thumbsup:
Words. What do words mean? :slightly_smiling_face:
<@U04V70XH6> Not what I indend them to mean normally. :wink:
`(defmulti DWIM identity)`
is there a convenient way to disable implicit binding conveyance ?
<@U053XQP4S> In jvm clojure the simplest thing is to start a thread via interop instead of using one of clojure's utility functions for creating threads `(.start (Thread. (fn [] (println "hello"))))`
any zero arg clojure function is a valid argument to the thread constructor, and will be the thing the thread does when started
this method of running a function only sees global bindings, and won't convey any local dynamic bindings
ok so I guess it is somehow against the language to try to use dynamic vars as thread locals ?
well - they are thread local, they just get conveyed to other threads if you use things like future or send-off
or core.async stuff
I thought what you were asking for was how to avoid the inheritance of those thread local bindings
(or to create a new context without them at least)
what I'm trying to achieve is a mechanism for detecting if a function call has been made out of a synchronous context
what is a "synchronous context" - synchronous with what?
that is, I can easily start code inside core.async go that is synchronous within itself but async with the caller - and it's easy to end up with an app where almost everything is "async" if you go far enough up the call stack, but in practice nearly all of the logic is sync
it's hard to find a minimal example, but basically I create event queues, I have functions that must be "bound" to a single event queue, so I need a way to test if I'm currently running this queue, if so it's ok to run synchronously, else you have to post an event
a threadlocal is a good way to achieve this, but if I use dynamic vars, the event queue context will be conveyed
sounds like instead of avoiding binding conveyance, you could just rely on it, and set a dynamic var `*in-queue*` to true and get the right behavior?
oh, so children of the queue shouldn't inherit that context, only the queue worker itself should have it?
yes, if I use `future` while I'm the queue, I don't want the thread running the future to believe that it's still in the queue
you could create a global set at the ns level with the queue Thread instances in it, and check if `(Thread/currentThread)` returns something in that set
that's cheap and the logic is simple
Does anyone have an invite to Screenhero they could throw my way?
it's similar to using a threadlocal, isn't it ?
slack has now integrated screensharing into slack directly
in the `/call` stuff ...
(pardon, misread)
Huh, I'll try it out.
Thanks
kind of - but the emphasis is different - instead of setting a threadLocal in each thread, you add each thread to a container that keeps track of them
one is global, explicit, and visible, the other is hidden and implicit
Hm, looks like it's paid teams only. Not useful in this case.
<@U051SS2EU> ok I will think about that - thanks anyway, but I'm still a bit confused about the dynamic var philosophy
it's meant for things that would be visible to this thread and all the ones it creates
eg. think about how `with-out-str` works - it overrides the destination for printing for the caller and all child threads
the implicit aspect looks a bit dangerous to me, and the only benefit I see is to save a few characters when you write your functions
Question: How would I extend a protocol to all array types? I seem to only be able to do it for a specific array, like say "[Ljava.lang.Object". But I want "[L?"
there is no such thing
:disappointed: Its strange that "[Ljava.lang.Object" doesn't even work for subtypes of Object. It only works if I have actual array of Objects
that is how array types work on the jvm
array types don't have that kind of type relation
if A is an array of X and B is an array of Y, and Y is a subtype of X, B is not a subtype of A
I'm not convinced, since instanceof can tell the relation
<@U0NCTKEV8> java array are covariant, it's generics that aren't
Oh
