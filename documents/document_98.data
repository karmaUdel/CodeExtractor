U485ZRA58 : Oops, my bad. Missed that
U485ZRA58 : That should work
U071CG4QY : Though I don't know if there is any point to removal of `(second group)`
U071CG4QY : You may as well do this `[[hash [{file :file} second] :as group] %]`
U69HWBFB3 : <@U071CG4QY> Correct. That is my initial version. But don't you think destructured version is more readable?
U071CG4QY : <@U69HWBFB3> Nope, imo — you need to parse destructuring and for that structure it is not very easy.
U66G3SGP5 : when using datomic, if I can freely choose between an SQL backed datomic or Cassandra backed datomic, which one is better?
U0BB79MMJ : <@U63RTB1KR> It's because of the way transducers work. They *are* applied from right to left, but to the reducer fn.
U0BB79MMJ : You can think of each wrapping the earlier transducers
U3GJHS5DY : <@U63RTB1KR> <https://clojure.org/reference/transducers> checkout "defining Transformations with transducers"
U46LFMYTD : I'm trying to do some Java interop using a Java library called Gurobi. I'm following their documentation which reads```
import gurobi.*;
...creates outer class...
GRBEnv env = new GRBEnv("mip1.log");
GRBModel model = new GRBModel(env);
GRBVar x = model.addVar(0.0, 1.0, 0.0, GRB.BINARY, "x");
```
I am trying to work with this library in clojure. It seems I cannot wildcard import in clojure so I have 
```
(import '(gurobi GRB GRBCObj GRBCallback GRBColumn GRBConstr GRBEnv GRBExpr GRBException GRBGenConstr GRBLinExpr GRBQuadExpr GRBModel GRBSOS GRBVar GRBQConstr GurobiJni))
(def env (new GRBEnv "mip1.log"))
(def model (new GRBModel env))
(.addVar model 0 1 0 GRB.BINARY "x")
```
however I get the error on the final line "java.lang.ClassNotFoundException" caused by GRB.BINARY. I believe I have imported everything using the extensive import above.

U0BB79MMJ : <@U46LFMYTD> Might be a static member, so it could be `GRB/BINARY`
U0BB79MMJ : Or, an inner class, in which case you need to import `GRB$BINARY`, but from the upper case spelling, I'd assume the former
U46LFMYTD : bingo
U63RTB1KR : <@U0BB79MMJ> <@U3GJHS5DY>  Thx. I'll check it again.
U46LFMYTD : it was `GRB/BINARY`, thank you
U46LFMYTD : How would I convert `x.get(GRB.DoubleAttr.X)` to clojure
U46LFMYTD : cider in emacs isnt giving me much help &gt;&lt;
U46LFMYTD : can someone please help me convert `x.get(GRB.DoubleAttr.X)` to clojure code
U46LFMYTD : so turned out I needed this
U46LFMYTD : `(.get x gurobi.GRB$DoubleAttr/X)`
But I'm confused as to why I needed gurobi.GRB$DoubleAttr instead of GRB$DoubleAttr as I already imported gurobi.GRB in my import statement

U46LFMYTD : and when I begin to type `gurobi.GRB$Dou....` cider doesn't autocomplete it
U46LFMYTD : so this worked `(.get x gurobi.GRB$DoubleAttr/X)` but i feel like im in the dark
U46LFMYTD : cider isn't giving me any autocompletion help so its hard to find the proper structure
U46LFMYTD : cidre doesn't autocomplete `gurobi.GRB$...` at all
U0BB79MMJ : <@U46LFMYTD> Yeah, nested classes are confusing to work with... You can probably directly import GRB$DoubleAttr as well, that should fix it
U051SS2EU : <@U3JURM9B6> <@U1ALMRBLL> clojure has eager-map built in, it's called mapv, and it will perform better than that reduce example, even if you need to call seq on the result to get a list instead of vector
U0G75ARHC : what's the best and most elegant way when using `environ/env` to ensure that values that can be coerced end up being so. Right now everything it reads as strings. I'd like values like "true"/"false" and numbers to be converted to be of the right type
U0G75ARHC : Tried simply using edn/read-string, but it turned out to be not so straightforward.
U0G75ARHC : some edge-cases when the exceptions thrown, I end up with code that doesn't look elegant. Clojure has spoiled me: If code doesn't look elegant - I feel it's not worth adding it.
U051SS2EU : I wonder if `plumatic/schema` coercers would help here…
U051SS2EU : <https://github.com/plumatic/schema#transformations-and-coercion>
U051SS2EU : &gt; Coercion is like validation, except a schema-dependent transformation can be applied to the input data before validation.
U051SS2EU : <@U0G75ARHC> consider that you'll read this at startup, and IMHO startup is the perfect time in the run of an app to reject input outright and exit with an error
U051SS2EU : so I'd say, don't try/catch, even explicitly throw AssertionErrors if the data isn't "perfect" - then whoever set up the run environment can use your clear descriptive error message to fix the input and try again
U0G75ARHC : <@U051SS2EU> I'm not using schema in this particular project. Seems to be an overkill to have to use it to solve this particular problem
U051SS2EU : OK - but my point about asserting / throwing / bailing out still stands
U09A6U6GJ : RFC, all contributors to and users of nREPL: <https://groups.google.com/forum/#!topic/clojure/6SX7q39lK90>
U051TMSBY : <@U0G75ARHC> you can check out <https://github.com/amperity/envoy> too
U2J7JRTDX : ag: Use `aero`: <https://github.com/juxt/aero>
U0W0JDY4C : is there a way to change the signature of a defmulti after you decide on which arguments to dispatch?```
(defmulti foo (fn [a b] [a b]))
(defmethod foo [:foo :bar] [just-foo?] (do ...))
```
or does every defmethod have to have the signature `[a b]`?

U0NCTKEV8 : the defmethod only needs to be able to be invoked on the args given to it
U0NCTKEV8 : so if you have a mutlimethod that can be invoked with differing numbers of arguments, and those differing  numbers of arguments are dispatched differently, each method only needs to handle the arity it would be invoked with
U0NCTKEV8 : if you invoke a multimethod with N arguments, whichever method it dispatches to will be invoked with N arguments, you can't change that
U0W0JDY4C : okay, that makes sense. I just didnt want to have to change my signature across a couple files that implement the defmethod *if at all possible
U0K0TFQLW : <@U0G75ARHC> <@U051SS2EU> I did exactly that using the json coercer that ships with schema
U051SS2EU : yeah- that's what I was thinking of
U0K0TFQLW : I have a file in each of my projects that looks like ```(def settings {:debug {:schema s/Bool :default false}   :db-uri {:schema sc/URI :default "<postgres://postgres@localhost:5432/foo>"}
   :redis-uri {:schema sc/URI :default "<redis://localhost:6379/0>"}})
```

U0K0TFQLW : and then I have a component that takes a settings map in and can realize those at component/start time to be injected around to whomever needs them
U0K0TFQLW : although I have a vendoring of environ.core/env's underlying functions to allow me to invoke it in my start() and thus allow me to stop a system, change java properties, and then start the system again


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
