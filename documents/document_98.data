```
From what I gather the answer to this would be "you only have one implementation per keyword; you just use a different config"
Right. Just take the base config and alter it with `assoc`. Or use `duct.core/merge-configs` to merge in new options.
It effectively amounts to the same thing.
You *could* also use `with-redefs` to redefine the `init-key` multimethod, but since that's not thread-safe I'd advise avoiding that route.
Thanks for the explanation! So the gist is that I was finding it annoying to swap implementation due to multimethods, but that's intentional because under your design you *should not* swap implementations
Right. I mean, in theory it might be good for testing, but in practice I think it makes more sense to substitute keys in the configuration, rather than make the config-&gt;implementation bridge dynamic in some fashion
It also makes it explicit where you're stubbing/mocking.
<@U0BKWMG5B> thanks for taking the time to explain this out. Once I understand Integrant/Duct better I'll try to give back by writing some doc :slightly_smiling_face:
Thanks! But if you like, just some feedback once you've gotten to use it a little would be  useful. The more use-cases I know about, the more useful I can make the library.
Certainly
Hi! What is the preferred way to do input payload validation for a json api in Clojure? If possible a solution that offers both input validation and machine-readable errors to be consumed by the client. Hopefully I won't start a 40min heated debate like yesterday :smile:
Just adding stuff from this conversation to the readme / wiki would be helpful, because as far as I could see the questions are not addressed on Github at the moment
sort of "Best practices" for stubbing / mocking with Integrant
<@U3L6TFEJF> yep that would be great
I'd read one, though :opieop: 
Point taken, I'll put together something for the Duct docs.
<@U0BKWMG5B> are you using Duct in production?
The Integrant version? Not yet, or at least it's not *running* in production. I am working on an app that will be running in production in a couple of months, though.
<@U0BKWMG5B> Another question… What would be the preferred way to reference some environment variables in the config? It seems to be like an EDN tag would be neat, e.g. `#ig/env "DATABASE_PASSWORD"`. Do you have an existing option? I guess I could merge in the relevant config from env vars
An edn tag would be neat, and in Duct it's called `#duct/env`.
If you put that in your main `config.edn`, then you can always override them in `dev.edn` or `local.edn`.
Oh I hadn't even realised Duct had this functionality; I am focussing on Integrant's doc atm. Brilliant
Certain modules also have defaults, e.g. `:duct.module/sql` uses `JDBC_DATABASE_URL` and `DATABASE_URL` automatically, and `:duct.module/web` uses `PORT` for the port number.
<@U5ZAJ15P0> There are a few solutions. Compojure-API can use Schema or Spec. My own Ataraxy has spec validation in the latest version. There are also various validation and coercion libraries, but I think the most common approaches are Schema or Spec.
Spec isn't designed around coercion so much, so I'm not sure how well it could handle that.
<@U0BKWMG5B> on the topic of loading env vars, maybe it would be neat if one was allowed to extended integrant with custom readers?
oh hang on; I just looked at Integrant's code and it's already the case
Take a look at read-config
Yep :slightly_smiling_face:
<https://github.com/weavejester/integrant/blob/master/src/integrant/core.cljc#L85>
Though in duct someone pointed out that the readers don't persist though includes, so that needs to be fixed.
<@U0BKWMG5B> what do you mean by that?
Duct adds a :duct.core/include key that allows a config to pull in other configs from the classpath in the "prep" stage
But prep doesn't know about the custom readers.
I'm also considering better ways of performing an include.
<@U5ZAJ15P0> wrote a post about the coercion &amp; error messages some time ago: <http://www.metosin.fi/blog/clojure-spec-with-ring-and-swagger/>.
thanks!
<@U0BKWMG5B> another question… Is there a way to "inherit" from a config? For example, let's say I have a "database" config, and I want to create two services whose configs are slight twist over the general "database" config
a bit like your `:adapter/jetty` example on the Integrant readme
except that you replicate the config (port and handle) under both keys, whereas I would like to share a config block and override some bits
if that makes any sense
(theoretical question anyway, I don't have a specific usecase)
Not currently, unless you modify the config with either a module or directly after it's loaded.
So I would need a module that knows about those keys and performs a merge?
I'm using integrant-repl and reading config from `resources` folder in my preparer function (`(read-config (io/resource "config.edn"))`) and yet it won't pick up new values for mongodb host when I change them, forcing me to stop and start the REPL. Does this ring a bell to anyone? Any common gotchas?
<@U0BKWMG5B> ^
Quick question: how can I pass a static function around? E.g. if I try to pass `System/getenv` around I get `Unable to find static field: getenv in class java.lang.System`
(but `(System/getenv "foobar")` works)
I could pass `#(System/getenv %)` around, but I assume there is a simpler way
that's a static method, methods unlike functions are not first class objects supported by the vm
you can't pass something as an argument that can't be put on the stack
that's why you need to create a function, which is an object (with a static method that gets called if you apply it)
so tl;dr there isn't a simpler way, that's the way you do it
<@U5ZAJ15P0> you could check `memfn` as well <https://clojuredocs.org/clojure.core/memfn>
<@U053XQP4S> that doesn't work with static methods
and it's not any more succinct or efficient than creating a lambda in most cases
(that's what it actually does, it creates a function)
oh right, my bad
<@U051SS2EU> ah I see; I thought there might be something like that going on
i don't understand why this returns what it does. can someone break down what `reduce` is doing here?
<@U6DBQRAHM> head to <#C053AK3F9|beginners> and I'll walk you through it
<@U11BV7MTK> ok thanks!
I'd need to see more of your setup. If you're performing a reset, your prep function will be hit
Yes, though depending on your use case, it may or may not be a good idea
<@U0BKWMG5B> yet another question on Integrant… Why is `ig/suspend!` necessary? Couldn't you do all the logic in `ig/resume`? (naming it `ig/swap` or similar). It seems to only be used when hot-swapping for dev
There are two steps: suspending the system then resuming it with a different config
To do essentially one thing: hot-swap some parts of the running system
(at least that's the only use of suspend!/resume I have seen yet)
Consider the case of a web server. Suspend can tell the server to buffer connections until resume is called. After suspend we reload namespaces which can take several seconds.
Suspend and resume are only used for dev
ah right, so you wouldn't be able to hot-swap in one go because reloading namespaces while requests are being processed would lead to issues I assume
Ring will buffer requests by default if the handler is a promise?
well, the ring jetty adapter
Yes, because a promise blocks
Ah, so if the passed handler is a promise it will try to deref, which will block. ok.
thanks!
Right
Suspend and resume are useful for keeping connections open and avoiding restart time during development.
Web sockets for example
(similar to what the debugger in IntelliJ allows you to do)
`bean`
wouldn't work on non-beans
I tried to make sense of `clojure.reflect` but before I spent my time on that - shall we say - sparsely documented lib, I was wondering if someone had a neat `java-to-map` fn
I think clojure.reflect/reflect basically does that iirc
if I recall, bean used to be more general and didn't look for JavaBean specific stuff... let me see if I can find it
