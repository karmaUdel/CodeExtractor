```
<@U1ZFF0E5P> <http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#map2>
so that will give you a dict with 1 value, but what you perhaps want is to create a decoder of `Decoder List (k,v)` in which case you can map over it with `EveryDict.fromList`
Just curious, has anyone used elm as a stepping stone to learning Haskell? And if so, how big of a transition was it?
I know both, if that helps.
I think Elm hides most of the complexities of pure functional programming, so the biggest stumbling blocks will probably be the same ones as all beginner Haskell people have. Things like needing to know how effects work "under the hood" if you like, but you've definitely got a leg up because you'd know the syntax and if you understand types quite well you know the basics, so that's good :slightly_smiling_face:
<@U6E03KDPE> here's a book that might be helpful on the way... I helped write it: <http://happylearnhaskelltutorial.com|happylearnhaskelltutorial.com> though it's really aimed at people who are total programming beginners
I'll give that book a look! I ask because so far this past summer I've been working through the haskell book. It's been kind of hard to get going though, because it seems like the barrier to being able to write programs that aren't just example problems is a little high, and it been kind of demoralizing. I came across elm, however, and it looked like it would be a good way to learn some of the stuff of haskell, while being able to quickly get some applications off the ground
Yeah, the book is organised that way a bit. Most haskell books are. That's one of the troubles with Haskell, I guess. You have to pay a large cost upfront. Contrast that with Elm or purescript, and well you can get going straight away almost. Possibly that's because they're focussed on web dev, but in the case of Elm it's probably mostly because that's its focus.
My book's designed to get you understanding code as quickly as possible. That has the obvious downside that you won't understand it in entirety... which is why I try to get people to not try to write any code on their own until the very end, and only then is it quite basic stuff, because I don't want people to burn themselves, or get frustrated. So, it ends up being quite "guided" in that sense.
I found getting the basics of the Haskell language was pretty straight forward but dealing with the ecosystem of libraries was a big pain. Elm and even haskell tutorials won’t prepare you for every library having their own set of custom operators
Sure, but operators are "just functions", right? :slightly_smiling_face: (functions that "take" two arguments, albeit in a weird way)
yep, nameless functions with custom precedence
Elm has some, too.... like `(==)` for example. (or `(&gt;&gt;)` `(&lt;&lt;)` `(&lt;|)` etc)
Yeah, just learning the std library has been a bit of an exercise in patience lol
Elm core does, but most libraries don’t
For me, as soon as I realised operators are "just functions", they weren't a problem anymore.
It’s rare to find operators in Elm libraries
There are hardly any operators in the GHC prelude.
About 14 I think?
Granted they *are* named pretty weirdly, some of them :slightly_smiling_face: (Like `($)` which is `(&lt;|)` in elm, or `(&lt;$&gt;)` which is a general version of `map` in elm, etc)
As someone that struggles to recall the predecence of the arithmetic operators, having new operators in every library is insurmountable
interesting
I've never had a trouble with that, and I always have to look up operator precedence in JS all the time.
I guess it might be my development style - I make very tiny little changes, and recompile at every step.
I just wrap operator application in parentheses
cool :slightly_smiling_face:
Also theres the infix package in Haskell
Which reveals `&lt;&lt;`, `&lt;|` and the like
reveals? We already have `&lt;&lt;` and `&lt;|` but they're named different things.
&lt;$&gt; and map literally have the same number of key strokes
i've got a string "abc:123" and a type `type ID = ID String Int` and i'd like to decode the former into the latter
