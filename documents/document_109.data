```
then I end up "inverting" the doseq / modification to the @state atom in order to get my reduce code
<@U3JURM9B6> There's nothing inherently wrong with that, in my opinion. For me, it's a quite common pattern that I pull out the transducers once I start noticing boilerplate and repeating patterns in the code.
<@U06B8J0AJ>: have you used Haskell? the haskell solution to this would be the 'state' monad, then an external sequence_
<@U3JURM9B6> Unfortunately I haven't used it beyond the tutorial on the home page (which is quite nice)
`map` does seem to be easier to visualize than `reduce` though. I think `map` corresponds more to everyday patterns of life. You can imagine walking along a row of potted plants and watering each for example, getting a row of watered plants.
But what would be the `reduce` version of that? Repot them in one large pot, one plant at a time?
But also, the order in which they were repotted would somehow matter. I don't know, it's not _as_ straightforward.
<@U3JURM9B6> in Haskell how would you solve the problem?
`foldr` over a sequence?
(I'm just curious)
<@U66SFLTPT> : I would write the code "imperatively" with putState / getState, then  put it on a do block + use sequence_ if there's a list
I find it easier to go `write using loop/recur` -&gt; `refactor to reduce`
but then the reduce somehow causes me to "invert" the state manipulation
generally, than doseq. because that way you just delete a bunch of code and change some keywords. refactoring doseq and atom updates is annoying
<@U050MP39D> : loop/recur is definitely closer to reduce than doseq/atom
nevertheless, it seems that in an otherwise clean language, there's this mismatch between "mental thought" and "how code has to be written"
or maybe I just haven't mastered reduce idioms
mmmmmm my assumption is that that mismatch is just a result of spending so much time in imperative languages. I definitely find myself having to go through that interim step a lot less than I did 4 years ago when I moved ruby-&gt;clojure. could be wrong though
haskell is not exactly '
imperative' -- some would say it's even more 'functional' :slightly_smiling_face:
<@U3JURM9B6> Is there no notion of `reduce` in Haskell though?
that's foldl
there is, and it would be considered *way* more idiomatic than using the state monad
haskell definitely has foldl / foldr, but it also has state monads + sequence_
and it's provable that everything you can do via state manipulation you can do in a left fold / reduce, it's just a different code pattern to do it
I would say, any time you're bashing state, state monad is more idiomatic than folds
and with reduce, the initial value is basically your 'local state'
the state monad is a "purely functional statically typed" math trick around writing an imperative looking thing and still keeping it pure
yeah, I guess 99% of the problems I have with clojure is: it doesn't have haskell's type system :slightly_smiling_face:
funny, that's my favourite thing about clojure :laughing:
<@U3JURM9B6> frege is haskell for the jvm, and it would even be usable except it is too hard to use interfaces or extend java types (because it really does implement haskell's type system - which is better but also alien to the platform)
I tried using frege once; I found neither the documentation nor the community helpful.
I would have totally used it for some things in my codebase but not being able to define or implement interfaces (not to mention concrete inheritence, which clojure taught me how to do without), it was a no go
Is there a way that others are using tools like `eastwood` with files that contain namespaced keywords?
<@U3JURM9B6> I think their assumption is "just do it the way you would in haskell"
thing is clojure just has no need for a state monad, because if imperative code is what's appropriate there *are* mutable options
Well, cognitively, our problem solving is very pattern based. A problem occurs-&gt;go fetch the nearest solution from memory that approximately fits problem-&gt;apply to problem. Certain mismatch is bound to happen when encountering a somewhat different paradigm.
Personally, I find macros to be some of the most intractable marshlands of the language. The parser in my head doesn't predict the output of a macro well at all.
<@U051SS2EU> I really liked the promise of Frege and spent quite a bit of time working with it -- I wrote a Leiningen plugin for it and put out some mixed Clojure / Frege code examples. But, ultimately, I just found it too frustrating to use and kept going back to Clojure... which kinda fits in with the love/hate relationship I've had with Haskell ever since it appeared (I always hoped Haskell would rule the world but it seemed like the team behind it tried very hard to make sure that didn't happen!).
yeah I think I might have first heard of frege from you - and if I could have just defined / implemented interfaces I could have used it for my project…
I just watched Prof Turner's talk about "Some History of Functional Programming Languages" from the Poland FP conference this year. Great to hear how everything came together (he was going to be my external examiner for my PhD thesis back in '86... if I'd actually completed it!).
We used Miranda at my university and I was familiar with ML and SASL and a bunch of the other FP languages that all merged into Haskell. I created my own (SURE), just like all the other FP researchers in England at the time! :slightly_smiling_face:
Whereabout did you study?
I remember checking out CLEAN shortly after I got into software (by reading "tech yourself C++ in 21 days")
in retrospect I'm amazed I got turned to such an interesting direction so early on
<https://www.youtube.com/watch?v=QVwm9jlBTik&amp;__s=csfyzpydsvfikkqz5bvw> (for those who missed the link in Eric's <http://PurelyFunctional.tv|PurelyFunctional.tv> newsletter)
University of Surrey (Guildford).
SURE was Surrey University Recursive Evaluator :slightly_smiling_face:
ooh, makes sense!
