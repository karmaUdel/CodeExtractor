U0BKWMG5B : Since I'm a secondary source, and it's late
U04V70XH6 : That's Alex Miller's talk today?
U04V70XH6 : Looking forward to the video ... hopefully tomorrow? :slightly_smiling_face:
U0BKWMG5B : Yep, Alex's talk was on the `clj` script, `deps.edn` thing.
U0BKWMG5B : I'm kinda thinking about a `build.edn` now…
U0BKWMG5B : Or a `tasks.edn`, either in the project root, or included in the resources path.
U04V70XH6 : We use `deps.edn` for regular coordinates today and load them from various subprojects and concatenate them (and then update them from a list of "pinned" versions in a `versions.properties` file) as part of our dynamic Boot-based dependency analysis.
U0F27GHT7 : Is there a way to do something like map fusion on lazy seqs? Does it even make sense to do that (given chunking, or for some other reason I haven't thought of)?
U0NCTKEV8 : <https://clojure.org/reference/transducers>
U0F27GHT7 : Thanks! I'd been under the impression that transducers only made sense in an eager context, but further research suggests that belief may have been oversimplified :stuck_out_tongue_winking_eye:.
U0W0JDY4C : i feel like i'm missing 2 things about protocols;1) if a record implements a protocol, and that record has fields defined in `defrecord MyRecord [foo]`, what's the difference between using `foo` and `(:foo this)` in a protocol function's implementation?
2) how does a protocol call one of the other functions defined in its own protocol interface? I'm getting compiler warnings about `my-protocol-func not defined` if attempting to do something like
```
IMyProtocol
(foo [_ a] ...)
(bar [_ a] (foo _ a)
```

U051SS2EU : protocol functions need to be used the same way you would any other function
U0NCTKEV8 : you look like you might be using the interface generated by the protocol instead of the protocol
U051SS2EU : they belong to the other namespace
U051SS2EU : you could also use the method call syntax `.foo` without namespacing of course, but it's better to use the protocol function
U0W0JDY4C : ahh.. they are defined in the `protocols.cljs` so you have to `protocols/foo` in the above example
U051SS2EU : right
U051SS2EU : very common beginning mistake with protocols - to think their functions are like methods
U051SS2EU : (and they are - but not in this aspect)
U0W0JDY4C : so the `this` context is kind of the method context? "invoke my protocol func on `this`"
U051SS2EU : it's the object that the method was called on - and don't call it `_` if you are going to call a function on it
U050MP39D : I would say the answer to your first question is "there is no difference use whichever you prefer"
U051SS2EU : `_` is a naming convention that means "I plan on ignoring this, on purpose"
U0NCTKEV8 : the behavior of `this` is likely slightly different in clojurescript vs. clojure
U050MP39D : although honestly I haven't used a defrecord in 2 years so I may be misremembering something
U0NCTKEV8 : (this meaning the first argument to something defined inline on a defrecord, deftype, or reify)
U051SS2EU : I suspect that using the name of the field directly leads to a faster lookup, but if that difference means anything in your code you probably want something more performant than a record anyway
U0W0JDY4C : so even if I invoke `(protocols/foo this)`, it still doesnt matter if I refer to the record's field or the `(:foo this)` because at that point the context has already changed
U0NCTKEV8 : what?
U0NCTKEV8 : the first argument is always going to be the thing you invoked the protocol function
U0NCTKEV8 : on
U0W0JDY4C : ```(defrecord MyRecord [field]
  IMyProto
  (foo [this a] (do-something field)) &lt;- here shouldnt matter if I use field or (:field this)?
  (bar [this a] (protocols/foo this a)
```

U0W0JDY4C : I just want to make sure I dont get this very subtle bug by implementing a protocol that's using a field versus a lookup on this, when self-referencing(?) a protocol
U050MP39D : `field` and (:field this) will always be the same thing
U0W0JDY4C : i've been stabbed in the foot by javascript so many times I'm very paranoid
U0W0JDY4C : okay, good to know the context stays the same no matter how it's invoked
U0W0JDY4C : thanks <@U0NCTKEV8> <@U050MP39D>  <@U051SS2EU> :thumbsup:
U0W0JDY4C : ```let my_obj = {
  lolGoodLuck(args) {
    let that = this
    function() {
      that.call(this, args)
    }
  }
}
my_obj.lolGoodLuck.apply(youWillNeverGuess)
```

U17DY48BW : Got a tough problem if anyone has an answer. Basically I have a large data structure (vector of hashmaps) about 50,000 hashmaps. And I need to pass the data to a Java function, but the hashmap has keyword keywords and those keywords need to be transferred to strings for the java function. Is there a fast way to convert keyword keywords to strings? right now the conversion takes about 2 seconds
U07S8JGF7 : Use strings from the start instead of keywords?
U07S8JGF7 : You're talking linear time + string manipulation. Probably not a fast operation no matter how you slice it.


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
