U3JURM9B6 : sample randomly from [0, 1]
U3JURM9B6 : index into the cumulative probability
U0524T275 : yeah I thought about that, so I guess there is no easier way?
U61HA86AG : wouldnt repeating each choice depending on the probability and then using `rand-nth` do the trick?
U0524T275 : that would work in a simple case like this one
U0524T275 : but in the general case I would need to find the LCD of all the fractions
U0524T275 : and generate a massive vector with all the repeated stuff
U61HA86AG : right, i see
U3JURM9B6 : suppose an item has probability .3957 , do you repeat it 3957 times? :slightly_smiling_face:
U61HA86AG : fair point
U0524T275 : Something like this gives me the ranges I can then check```
user&gt; (def probs {0 1/2 1 1/4 2 1/4})
#'user/probs
user&gt; (into {} (map-indexed
                (fn [idx [el prob]]
                  [el
                   [(apply + (take idx (vals probs)))
                   (apply + (take (inc idx) (vals probs)))]])
                probs))
{0 [0 1/2], 1 [1/2 3/4], 2 [3/4 1N]}
```

U0524T275 : quite sure it can be improved a lot though
U071CG4QY : <https://stackoverflow.com/questions/14464011/idiomatic-clojure-for-picking-between-random-weighted-choices>
U0524T275 : nice thanks
U5ZAJ15P0 : I am pondering about how I would implement a simple compiler and/or interpreter in Clojure. In particular, I am wondering what would be the best way to model the abstract syntax tree.
The first (and most obvious) option would need to represent AST nodes as maps, tagged with their type/label (e.g. :type key). I would then define the various functions that operate on the AST as multimethods using the node's types as dispatch keys.

Another option would be to represent each type of node as a record, and to then have them all implement a protocol (e.g. IExpr) which would contain have implementations for all the functions operation on AST nodes. This comes wth the added benefits that AST nodes could implement existing protocols too.

Which of these options would be most idiomatic in Clojure? Or do you have another one to suggest?

U5XMV6DQT : Take a look at Instaparse
U050SC7SV : clj-antlr isn't bad either
U5ZAJ15P0 : Which parts in particular? I am not looking to write a parser, just to understand what the best way to model an AST in clojure would be
U5XMV6DQT : multimethods are nice, I think
U5XMV6DQT : I made a notice about instaparse because if you use it — you don't have to think about AST representation yourself
U060FKQPN : <@U5ZAJ15P0> take a look at tools.analyzer
U060FKQPN : <https://github.com/clojure/tools.analyzer>  <https://github.com/clojure/tools.analyzer.jvm>
U5ZAJ15P0 : thanks! so from that I gather that raw maps with a :type field seems to be the way to go?
U5ZAJ15P0 : ok thanks, I'll take a look
U5ZAJ15P0 : Another, completely unrelated question… Does anyone have advice/examples on how to structure application business logic? This is a fairly general question (not specific to Clojure), but there might be Clojure-specific idioms coming into play. Roughly speaking I am wondering if I should take a CQRS-y road and try to have a clear distinction between functions that modify the app's state and functions that read that state. The application I am currently working on is a fairly simple, CRUD-y Clojure+Datomic web app, but I would like to use it as a learning ground for good practices
U5ZAJ15P0 : A link to an open-source application that you consider well-structured would be helpful, or advice / link to blog posts / resources
U06CM8C3V : <@U5ZAJ15P0> have you seen the docs for re-frame? He talks extensively about CQRS-y architecture (even though it's cljs not clj) <https://github.com/Day8/re-frame>
U06CM8C3V : There's a pretty detailed readme doc right up front, but don't be fooled, the real meat is in the docs/ folder
U5ZAJ15P0 : <@U06CM8C3V> ah, let me check it now, thanks! By the way, something I should have specified: I am looking for a way to structure my code while keeping it fairly straightforward. E.g. no crazy async at the moment; ideally I would like to keep everything synchronous
U5ZAJ15P0 : Oh wow, indeed
U060FKQPN : it's the most common way at least
U068SUJNT : When I do some calculation with pmap and want to use another pmap on the result. How I can I wait until the first pmap is done?
U5JUDH2UE : Does anyone know of a clean way to assoc in a field only if the field isn't null; otherwise return the map unmodified?
U11BV7MTK : <@U5JUDH2UE> merge
U5JUDH2UE : :facepalm:
U11BV7MTK : :+1:
U5JUDH2UE : Thanks, <@U11BV7MTK>
U0E0XL064 : merge will overwrite existing keys in the original map... this may (or may not) be the expected behaviour.
U11BV7MTK : change the order
U5JUDH2UE : I'm aware. That is what I want. It's just an optional field that should be tacked on only if it's not nil. (An authorization http header)
U11BV7MTK : `(merge {:field "value if not present"} my-map)`
U11BV7MTK : yeah exactly
U0E0XL064 : right :slightly_smiling_face:
U5JUDH2UE : I don't suppose there's a merge that would do `(merge {:a 1} {:b nil})` and return `{:a 1}`?
U11BV7MTK : that sounds orthogonal to merge. you want to prune your map after the merge?
U11BV7MTK : if it's just top level keys you could `(into {} (map (fn [[k v]] (when v [k v])) my-map)` would probably work
U11BV7MTK : there's probably an even better sort with filter
U11BV7MTK : `(into {} (filter (fn [[k v]] v) my-map)`
U214G9RAP : To clarify your intention is to load the entirety of output of the first pmap into memory, then consume it once its realised?
U11BV7MTK : and if you have possibility of false change the body of the `fn` to (some v)
U5JUDH2UE : All great ideas.I've gone with `(merge xs (when a {:a a}))`.

U11BV7MTK : that will clobber your original value i thought
U11BV7MTK : you need your original map second
U051SA920 : <@U5JUDH2UE> In that case you could do: `(cond-&gt; xs a (assoc :a a))`
U5JUDH2UE : Sorry, I'm mixing names. `xs` doesn't have a `:a` yet. There's no possibility of clobbering.
U11BV7MTK : :+1:
U5JUDH2UE : <@U051SA920> I quite like that one. :thumbsup:
U214G9RAP : If that's the case simply wrap the first pmap in a `doall`
```
(pmap #(println "b" %)
  (doall (pmap (fn [x] (println "a" x) x)
(range 1000))))
```

U5JUDH2UE : Is there a better way to do `(symbol *ns* 'symbol)`?
U5JUDH2UE : Huh, nevermind. Apparently I can do syntax quoting for the dispatch value of a multimethod. Not sure why I thought I couldn't earlier.
U0E0XL064 : <@U5JUDH2UE> Not sure if it would help, but <https://github.com/nathanmarz/specter> has some really 'navigators' to do all kinds of transformations on data structures. (Maybe not worth the effort for easy navigation, although I think it may be if you have at least 2 steps to navigate, including predicates :slightly_smiling_face: )
U5JUDH2UE : <@U0E0XL064> Huh, that's cool. Definitely overkill for this though. :slightly_smiling_face:
U173SEFUN : <@U5JUDH2UE> for associng a value if not null, with specter it's `(setval [:a some?] my-value amap)`
U5ZAJ15P0 : <@U0E0XL064> are those basically lenses?
U173SEFUN : for associng only if field exists, it would be `(setval (must :a) my-val amap)`
U173SEFUN : will be way more performant than merge as well
U0E0XL064 : I didn't use specter much yet - only found about it about a month ago - but it's definitely cool. Also for small cases.


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
