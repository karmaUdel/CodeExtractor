U051KLSJF : <@U3JURM9B6> usually you'll use `doall`
U051KLSJF : if you care about the return value
U1ALMRBLL : <@U3JURM9B6> it is fine, as far as I know, to pass a function with side-effects to `keep`, `filter`, etc -- the gotcha is that you should not *expect* that your code will necessarily execute. So, your side effect may happen, and if you don't mind, great -- but, your side effect might *not* happen, and that's why it says to avoid impure functions (or in some cases, may get called *more than once*).
U051SS2EU : it also might happen 31 times more than you expected
U051SS2EU : right
U1ALMRBLL : <@U3JURM9B6> not sure why you want a "strict list", but for eager evaluation with guaranteed "run-once", `reduce` would be a decent candidate to build it:```(defn eager-map [f coll]
  (reverse (reduce #(conj % (f %2)) () coll)))```

U1C03090C : Does anyone know how to specify a stylesheet for a scene in fn-fx (a clojure wrapper for JavaFx)? <https://github.com/halgari/fn-fx>
U3JURM9B6 : <@U051KLSJF> , <@U1ALMRBLL> : okay, so despite the docs saying "use pure function", it's actually okay to assume *atmost once, in order* semantics -- i.e. we don't know how far it will exec (due to evaling thunks at a time) -- but we can assume that:
1. thunks, if evaluated, at evaluated at most once
2. thunks, if evaluated, as "in order"
so
(head (map f '(1 2 3 4 5)))

won't do

(f 1)
(f 3)
eh, let's skip 3 &amp; 4 ... and then just eval (f 5) just for kicks

U46LFMYTD : hey <@U0DATSMH6> , <@U0CMVHBL2> , I didn't know that `identical?` could be uesd in such a way to examine structural sharing - thanks!
U1ALMRBLL : <@U3JURM9B6> in the case of the current implementation of `map`, I'd say so -- with the obvious disclaimer that making assumptions like this and relying on these details is not safe, and that I wouldn't use an approach like this (I'd prefer the `eager-map` function I put above, for example)in the case of something like a comparator, it's quite likely that it will be executed more than once, per pair, so you would definitely not get any guarantees there.

U5JEJN1CP : I'm getting a bizarre repl error that occurs only when reloading a file:```
2. Unhandled clojure.lang.Compiler$CompilerException
   Error compiling *cider-repl webtools* at (1:1)

1. Caused by java.lang.RuntimeException
   No such var: user/reset
```  
The project compiles fine.  The repl starts fine.  The problem only happens if I use `C-c C-x` to recompile.  If I restart the whole repl, it compiles fine.  It seems like it's trying to compile the repl buffer, but I can't for the life of me fathom WHY.  Wondering if anyone has any ideas what would cause this.  The only hit on stack overflow suggests that I must be requiring something `:as user`, but I'm definitely not.

U3JURM9B6 : <@U1ALMRBLL> : thanks for the eager map; it seems surprising that 1. core has no eager-map 2. many are probaly using (doall (map ...)) to simulate it, but 3. this revolves around assumptions that map doesn't really guarantee
U5JEJN1CP : Tried a `lein clean` but that didn't make any difference.
U3JURM9B6 : <@U5JEJN1CP> : what is user/reset ? is it part your lein config, part of cider, part of some reload package that you are using? [I use boot]
U5JEJN1CP : <@U3JURM9B6> User is the init-ns for a repl in my project.clj (lein config).
U5JEJN1CP : <@U3JURM9B6> so It seems that it expects a symbol `user/reset` that suddenly doesn't exist.  But looking over my changes from the past day I don't see anything that I would expect to affect that.
U5JEJN1CP : <@U3JURM9B6> Well, restarting emacs finally seems to have fixed it.
U3JURM9B6 : yeah, emacs can be quirky like that
U0666D1EK : How to avoid reflection warning in gen-class state. Specifically I looking for answer for this question <https://stackoverflow.com/questions/6625104/adding-a-type-hint-to-a-clojure-gen-class-state-access>
U69HWBFB3 : Hello fellow clojurians. I am eager to refactor part of my function that use destructuring but having some problem.
Here is a code snippet that has sequence of files that are grouped based on hash, uploaded and flattened back.

```
(-&gt;&gt;        
      items
      (group-by :hash)
      (pmap #(let
               [[hash [{file :file}] :as group] %]
               (if (upload hash file)
                 (second group))))
      (flatten))))
```

Is there a better way to destructure *group* into key and values to avoid performing `(second group)`?

U69HWBFB3 : Ok, so the only thing I came up with is:
```
(-&gt;&gt;        
      items
      (group-by :hash)
      (pmap #(let
               [[hash values] %
                 [{file :file}] values]
               (if (upload hash file)
                 values)))
      (flatten))))
```

Is it any good?

U071CG4QY : values is a vector
U69HWBFB3 : <@U485ZRA58>, <@U071CG4QY> is correct - *values* is vector. It may work if we update it:
```
(-&gt;&gt;        
      items
      (group-by :hash)
      (pmap (fn [[hash values]]
			(when (upload hash (:file (first values)))
                  values)))
      flatten)))
```

U485ZRA58 : Oops, my bad. Missed that
U485ZRA58 : That should work
U071CG4QY : Though I don't know if there is any point to removal of `(second group)`
U071CG4QY : You may as well do this `[[hash [{file :file} second] :as group] %]`
U69HWBFB3 : <@U071CG4QY> Correct. That is my initial version. But don't you think destructured version is more readable?
U071CG4QY : <@U69HWBFB3> Nope, imo — you need to parse destructuring and for that structure it is not very easy.


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
