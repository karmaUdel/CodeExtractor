U0NCTKEV8 : (following the thread with <@U0BKWMG5B>) it looks like he uses protocols for some stuff, so maybe that is less of a problem
U5ZAJ15P0 : <@U0BKWMG5B> the last web framework I looked into was Pedestal. Do you have any opinions on it?
U0NCTKEV8 : at my last job we used component but had a team member who hated defrecords, so we more or less retro-fitted component to use multimethods instead (which is pretty easy to do) which is where my experience with the pain of mocking that kind of thing comes from
U0BKWMG5B : I haven't use Pedestal in anger. Some ideas it has are good, but it feels more complex than what I need, and it's web-focused.
U0BKWMG5B : Duct/Integrant are more generic
U0LGCREMU : did i just kill a discussion?  ouch.
U2PGHFU5U : Interesting discussion. At my work we use mount (mount.lite actually), but I always liked the IoC-pattern in OO, which I miss doing mount. It is nice that you do not have to pass state as parameters everywhere, and if you want to mock a state you can substitute state for a mock implementation. BUT I miss having a composition root responsible for composing modules, and seeing that you have to refactor because a module takes too many constructor parameters.
U0CME35FV : <@U5ZAJ15P0> when you looking at mount, besides the docs, these little example apps may help you to see how it could be used: <https://github.com/tolitius/stater>
U5ZAJ15P0 : thanks!
U5ZAJ15P0 : <@U0BKWMG5B> sorry, watching the rest of your talk and reading a bit of Duct's doc I realise this was a silly question. Duct seems more like an approach to structure an application around Integrant
U2PGHFU5U : I find initializing state in one file like below (where a timbre appender is added) quite nice. I don't know what the equivalent would be for a Component application. Logging is a cross-cutting concern, so perhaps not really something you inject.
```
(ns blabla.logging
  "Logging setup for blabla."
  (:require [blabla.config :refer [config]]
            [clojurewerkz.elastisch.native :as es]
            [mount.lite :refer [defstate]]
            [taoensso.timbre :as log]
            [blabla.logging.elastic :as log-es]))


(log/handle-uncaught-jvm-exceptions!)

(defstate log-level
  :start (let [current-level (:level log/*config*)]
           (log/set-level! (:log-level config))
           current-level))

(defstate blacklist
  :start (when-not (:development config)
           (log/swap-config! update :ns-blacklist conj "io.pedestal.http.impl.*"))
  :stop (log/swap-config! update :ns-blacklist #(vec (remove #{"io.pedestal.http.impl.*"} %))))

(defstate elastic-client
  :start (let [{:keys [elastic-native-pair elastic-cluster-name]} config]
           (when elastic-native-pair
             (es/connect [elastic-native-pair] {"cluster.name" elastic-cluster-name})))
  :stop (when elastic-client
          (.close elastic-client)))

(defstate elastic-appender
  :start (when elastic-client
           (let [options {:base-doc {:app "blabla"
                                     :k8s {:namespace (:kubernetes-namespace config)}}
                          :mapping  log-es/mapping}]
             (log-es/add-elastic-appender! elastic-client "hd-logging" options)))
  :stop (log-es/remove-elastic-appender!))
```

U5ZAJ15P0 : Duct is a backbone, and all the web/else related logic is handled by other librairies, e.g. Compojure
U0BKWMG5B : Right. It provides a template, a bunch of integrant-compatible libraries, and "modules" which are essentially pure functions that transform the Integrant configuration.
U0BKWMG5B : Modules provide a way of automating gluing together libraries
U5ZAJ15P0 : <@U0BKWMG5B> do you have an example of how a module would work?
U0BKWMG5B : An example, or an explanation?
U5ZAJ15P0 : explanation, or an explanatory example :slightly_smiling_face:
U0BKWMG5B : Okay, let me find something quick…
U0BKWMG5B : Actually, I wrote a blog post about this, which might be more useful: <https://www.booleanknot.com/blog/2017/05/09/advancing-duct.html>
U5ZAJ15P0 : <@U0BKWMG5B> ah that's perfect, thank you!
U0BKWMG5B : One module is `:duct.module/web`. That sets up a handler and middleware, and looks through the configuration for a web server. If it finds one, it connects the handler to the existing web server. If none exist, then it creates a new one.
U0BKWMG5B : There's also: <https://www.booleanknot.com/blog/2017/05/29/building-web-services-with-duct.html>
U0BKWMG5B : The explanation I find myself often using for modules are web sessions that are stored in a SQL database.
U5ZAJ15P0 : how does it "find the web server" in the config? based on the name of popular web servers?
U5ZAJ15P0 : or a special key?
U0BKWMG5B : Keyword inheritance. The `:duct.server.http/jetty` key is derived from `:duct.server/http`.
U0BKWMG5B : So to find all the web servers in a Duct config, you just run `(ig/find-derived config :duct.server/http)`
U0BKWMG5B : The idea is to use `derive` a little like a dictionary definition or a thesaurus. It allows us to describe what a keyword is, to give it some meaning.
U5ZAJ15P0 : keyword inheritance is just based on the name + namespace of the keywords? e.g. a keyword X inherits from a keyword Y if X's namespace is Y's namespace plus its name?
U0BKWMG5B : No, it's its own thing. Any namespaced keyword can `derive` from any other.
U0BKWMG5B : Namespaced keywords have multiple inheritance in Clojure.
U5ZAJ15P0 : ah, I wasn't familiar with Clojure's `clojure.core/derive` function. I'll look into it before bothering you further
U5ZAJ15P0 : Thanks!
U0BKWMG5B : It's not often used, but I feel like it has some important niches
U0BKWMG5B : <https://clojure.org/reference/multimethods>
U5ZAJ15P0 : mmh, so `derive` is effectful from what I gather
U5ZAJ15P0 : Where does it hold the relationship data between keywords? A global registry? I can't see it setting metadata on the keywords themselves
U0BKWMG5B : A global registry. Derive *can* be used functionally if you supply a hierarchy, but mostly it's used globally.
U0BKWMG5B : To my mind it's like vars, or specs.
U5ZAJ15P0 : Oh, I think I get what you meant by a "grammar" then. You use keywords + derive to build a sort of ontology?
U0BKWMG5B : Exactly :slightly_smiling_face:
U0BKWMG5B : Jetty, for instance, is a HTTP server that supports synchronous and asynchronous handlers. So we could write:```
(derive :duct.server.http/jetty :duct.server/http)
(derive :duct.server.http/jetty :duct.server.http/async)
(derive :duct.server.http/jetty :duct.server.http/sync)
```

U5ZAJ15P0 : that's brilliant
U0BKWMG5B : If Integrant is the "grammar", Duct is attempting to build a "vocabulary".
U5ZAJ15P0 : So duct is an ontology for configuration + tools that understand and work with this ontology
U0BKWMG5B : Right. That, plus a way of transforming configurations via a preprocessing "prep" stage.
U0BKWMG5B : Basically query+transformation
U5ZAJ15P0 : I'll check out Duct's code if it's not too complex
U5ZAJ15P0 : That's super exciting
U0BKWMG5B : Start with duct/core
U0BKWMG5B : <https://github.com/duct-framework/core/blob/master/src/duct/core.clj>


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
