U4872964V : exactly, but the selection of data you do to put in a page does not get bigger just because your model gets bigger
U2LAL86AY : ah yes, because my users will have to do: `set (toFloat someInt ) ...` instead of `set someInt ...` - `number` will eliminate that conversion each time you call `set` function and you have an int somewhere.. is less overhead - to not bother if is an int or a float - since form a functionality perspective doesn't matter.
U4Z4NEUQG : Is there any reference for the JS API of elm?
U4Z4NEUQG : Like the `fullscreen()` method of modules.
U4872964V : but there are no ints between 0 and 1 :slightly_smiling_face:
U4872964V : i would go with Float anyway, calling toFloat is hardly a problem for the user
U2LAL86AY : 0 and 1 is included in that interval - maybe is not that bad but i would like to not have all this toFLoats everywere if they don't add anything useful..
U3SJEDR96 : <@U2LAL86AY> you can do `set 0.1` and even `set 1` for a `Bounded Float`
U3ZNWN526 : Or, if you really want users to be able to pass in `Int` variables, then you can accept a `number` and immediately convert it to a Float by multiplying it by 1.0 :slightly_smiling_face:
U3SJEDR96 : since `1 : number`, not `1 : Int`
U2LAL86AY : hmm you mean like this:`(1.0 * value)`
```
The right side of (*) is causing a type mismatch.

(*) is expecting the right side to be a:

Float

But the right side is:

number

```
pff this creates a lot of trouble than i need right now  - i will go with the float for now as <@U4872964V> mentioned - unthil that `number is not comparable` bug is fixed.

U3LUC6SNS : Does elm-tools/parser have a way of displaying the unparsed portion of the input of successful parse?
U4872964V : <@U3LUC6SNS> no, but you can perhaps trick it by pipelineing it with a fail parser to get the position
U3LUC6SNS : <@U4872964V>, thanks!
U1WJH1JU9 : I am trying to do some JSON decoding for a complex type that sometimes comes back null. When I get the types to match up, I only get back a Nothing type even when there is something there. Does anyone know what I am doing wrong?
U1WJH1JU9 : This is the code: ```|&gt; Json.Decode.Pipeline.optional "Feature" (Json.Decode.maybe decodeFeature) Nothing```
U4872964V : and the json is?
U1WJH1JU9 : ``` { rallyAPIMajor : String    , rallyAPIMinor : String
    , ref : String
    , refObjectUUID : String
    , objectVersion : String
    , refObjectName : String
    , createdAt : String
    , severity : String
    , changesets : ResultChangesets
    , description : String
    , formattedID : String
    , name : String
    , owner : ResultOwner
    , project : ResultProject
    , rtype : String
    , c_DefectSource : String
    , feature : Maybe ResultFeature
    }```

U4872964V : so, you have “Feature” instead of “feature”
U1WJH1JU9 : That is for the record. But the actual JSON has it with the capital.
U4872964V : well, if the decodeFeature fails, you’d get Nothing
U1WJH1JU9 : I agree. But even when it succeeds I get Nothing. That is the issue that I am having.
U4872964V : How do you know that it succeeds?
U1WJH1JU9 : Because I am logging the JSON that is coming back and can see that it has the appropriate field.
U4872964V : ok, so how does it look, and how does the decoder look?


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
