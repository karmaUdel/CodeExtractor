U051SS2EU : I'd say make your own function over transact that adds the data, probably parameterized with a hash map so you can generalize and introspect
U5ZAJ15P0 : so that I don't have to do this manually everywhere I call `datomic/transact` in my application
U5ZAJ15P0 : ok; thanks!
U051SS2EU : one thing to avoid is opaque wrappers (whether partial or an Object with hidden state - which btw is what a partial or closure is) - use a record implementing datomic's own protocol if possible, but parameterized by keys you can introspect on the record and access in context
U5ZAJ15P0 : <@U051SS2EU> is there a repl command to get the list of all protocols implemented by an object?
U5ZAJ15P0 : well, the record of which an object is an instance
U051SS2EU : supers
U5ZAJ15P0 : ah right because protocols are just interfaces
U051SS2EU : oh, supers needs the class, but that's easy enough
U051SS2EU : ```=&gt; (supers (class {}))#{clojure.lang.IKVReduce clojure.lang.IFn clojure.lang.IMapIterable java.io.Serializable java.lang.Object clojure.lang.IObj clojure.lang.IMeta java.lang.Runnable clojure.lang.MapEquivalence clojure.lang.IHashEq clojure.lang.ILookup clojure.lang.IPersistentMap clojure.lang.Counted clojure.lang.IEditableCollection clojure.lang.Associative java.lang.Iterable clojure.lang.IPersistentCollection clojure.lang.AFn java.util.Map java.util.concurrent.Callable clojure.lang.Seqable clojure.lang.APersistentMap}```

U5ZAJ15P0 : ```wef-backend.core=&gt; (supers (type (get-conn)))
#{#&lt;Class@35fc6dc4 java.lang.Object&gt;
  #&lt;Class@e7b265e clojure.lang.IType&gt;
  #&lt;Class@6b337969 datomic.Connection&gt;}
```

U051SS2EU : cool - so you can make a defrecord that implements Connection - the others come free with defrecord
U5ZAJ15P0 : is Connection a protocol there?
U051SS2EU : this is the point where I end up reading source code usually, heh
U051SS2EU : I bet it's documented … somewhere
U5ZAJ15P0 : I'll look into it. Thanks :slightly_smiling_face:
U5ZAJ15P0 : <https://gist.github.com/robert-stuttaford/39d43c011e498542bcf8>
U5ZAJ15P0 : I'll ask <@U0509NKGK> , I am sure he has insights on this
U051SS2EU : cool - thanks for asking about this, I learned a couple of things in trying to find your answer
U5ZAJ15P0 : <@U051SS2EU> Glad to hear that! I was afraid I wasted a bit too much of your time
U5ZAJ15P0 : <https://blog.clubhouse.io/auditing-with-reified-transactions-in-datomic-f1ea30610285>
U5ZAJ15P0 : In this article they wrap d/transact, as you were suggesting
U051SS2EU : well - they do it slightly differently than I suggested, because the user-id org-id and tx-data are totally hidden once you call defn
U051SS2EU : err, I mean once you call transact-wrapper
U051SS2EU : the return value of that function doesn't expose any of those things as data
U5ZAJ15P0 : <@U051SS2EU> do you think that's an issue? it seems to simplify the life of the caller, especially if he doesn't care about those
U5ZAJ15P0 : cluttering every function that calls transact with auth data that it doesn't care about sounds problematic
U051SS2EU : <@U5ZAJ15P0> until you are trying to debug code using the wrapper (in my experience) - it's not always neccessary to use the alternative of using a record to store the data instead of a closure, but what this gains is quick access to what the thing actually encompases
U051SS2EU : you don't clutter - the record itself is something you can call if you implement IFn - or you just expect people to use a protocol method with it as the first arg (also fairly reasonable but less fancy)
U5ZAJ15P0 : <@U051SS2EU> sorry, I think I am missing something. Can you give me a code example of what you mean?
U051SS2EU : hmm
U5ZAJ15P0 : Just a quick snippet here on Slack
U051SS2EU : OK - I was just looking at this right now, sorry about the distracting details, but the big picture structure should be illustrative of what I am saying ```(defrecord Transmitter [transmit from user-data creator to journey routing]  IFn
  (call [this] (.invoke this [nil this]))
  (run [this] (.invoke this [nil this]))
  (applyTo [this coll] (.invoke this (first coll)))
  (invoke [this [routing-override message]]
    (let [updated (into this message)
          routing (or routing-override routing (first journey))]
      (.invoke this routing updated)))
  (invoke [_ routing-override message]
    (let [{:keys [transmit generic]} message
          message (dissoc message :transmit :generic :routing :from :to)
          {:keys [journey routing message]}
          (if generic
            {:journey [routing-override]
             :routing :generic/reply
             :message (assoc message :generic-raw [routing-override message])}
            {:journey (rest journey)
             :routing routing-override
             :message message})
          {:keys [request-id birth-time]} user-data
          final-message (assoc message :journey journey :mediary to)]
      (when-let [schema-error (check-schema from routing final-message)]
        (log/error ::Transmitter
                   "for routing"
                   (pr-str routing)
                   (pr-str {:journey journey})
                   (pr-str schema-error)))
      (log/trace ::simple-kafka-transmit routing "to" request-id "from"
                 birth-time "-" (pull-transmit-info message))
      (transmit from routing final-message))))```

U051SS2EU : the transmitter has all this incidental data - who is sending? who is the target? what data did the initiator of the request expect to get back with any responses? what is the path the overall task should take through the system?
U5ZAJ15P0 : But that's basically the approach I was suggesting with a "DatomicWriter" protocol, no?
U051SS2EU : v1 wrapped this in calls to partial
U5ZAJ15P0 : that "wraps' transact
U051SS2EU : the difference is that this returns an object that acts like a function
U051SS2EU : maybe I misunderstaood what `@(d/transact ...)` is in the transact-wrapper function
U5ZAJ15P0 : right, but so instead of doing something like```
(transact transmitter conn tx-data)
```
you would do
```
(transmitter conn tx-data)
```

U051SS2EU : right
U5ZAJ15P0 : <@U051SS2EU> (d/transact returns a promise I think, and @ dereferences it


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
