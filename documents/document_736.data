U3R7CKQRX : But the subscriptions stay :confused:
U3R7CKQRX : As a workaround I guess one could have a js-to-elm port which will do something like this:```{model | destroy = True}
-- and then ...
subscriptions model = if model.destroy then Sub.none else ...(some subscription)
```

U14Q8S4EM : Yeah, I was just thinking, I wonder if you just set `subcriptions model = Sub.none` before you destroy it would work.
U3R7CKQRX : yeah
U3R7CKQRX : me too :slightly_smiling_face:
U3R7CKQRX : I think it would
U3R7CKQRX : for subscriptions that would help
U3R7CKQRX : But for `Navigation.program` and this that would work(if my assumption is correct that is listens to urlchanges and keeps the handlers)
U3R7CKQRX : I should take a look into the code for the navigation package. Having elm apps on a page and them doing stuff even when they shouldn't anymore is a little scary.
U0CLDU8UB : <@U1EQAULH2> Here's an article I wrote <http://futurice.com/blog/elm-in-the-real-world>
U3VH7AN30 : Hi there! I have a question about the update architecture. Let's say I have such code:```
type alias Model = {
    popup : Popup
}
type alias Popup = {
    isActive : Bool
}
type Msg 
    = PopupMsg Bool
    | SomeOtherMsg
```
When I handle `SomeOtherMsg` with my update function I then want to hide my popup. And now I have 2 ways of doing this:
1. Directly change my models popup in `SomePtherMsg` case branch like this:
```
let
    popup = model.popup
    updPopup = { popup | isActive = False }
in
    { model | popup = updPopup } ! []
```
2. Send a command with `Task.perform` like this:
```
model ! Task.perform PopupMsg (Task.succeed False)
```
So, what's the more correct way to do this? Thank you.

U3SJEDR96 : 3. make a function `hidePopup : Model -&gt; Model` and call it from both branches
U3VH7AN30 : <@U3SJEDR96> I thought about this but that's not the third option because it's just refactoring and can be done in both cases. 
U4872964V : well, I say 3. too even if it’s “just refactoring” :slightly_smiling_face:
U3VH7AN30 : Ok then. Just to clarify - preferred option is not to use commands?
U4872964V : yes, commands are for asynchronous stuff
U4872964V : potentially you will have some other message come in between
U4872964V : maybe it matters, maybe it doesn’t
U3VH7AN30 : Ah, now I see. Thank you for explanation))
U6AH7SUH5 : I'm an android developer and very intrigued by the elm architecture. I want to structure my apps similarly, unfortunately we don't have as much control over the view as web devs. 
My question is how to model things in the UI that don't really change the permanent app state. As an example, we have things called toasts (<http://www.materialdoc.com/content/images/2015/12/toast-1-1.png>) which is a small popup notification that disappears automatically. You would show it like this: `Toast.make("email sent", disappearDelay);`

Using a `EmailSent` state type is not always possible, because in android your application can be terminated and restarted at any time (for example when you rotate your phone to horizontal) and re-rendering the `EmailSent` state (since the `view` function would be called with the last state) when the app is restarted would lead to showing the toast again any time you rotate your phone.

U0CLDU8UB : Well, in Elm even things like toasts are part of the app state. There can't be anything like calling `Toast.make("email sent", disappearDelay);` and having the toast appear and disappear on its own in Elm. That's a profoundly imperative API, and effectively you give a piece of state outside the main program at that point. Neither of these are possible in Elm.
U0CLDU8UB : However, what would be sort of similar is sending stuff out through ports. Anything that happens outside of the Elm application can be imperative, so things like toasts can also happen in the imperative manner in that situation. Maybe that would be a nice analogy?
U6AH7SUH5 : how do you mean? I have been thinking about treating toasts somewhat similar to side effects. My state reducer/update function might look somewhat like this then:
```
fun reduce(view: View, state: State, event: Event) = when(event) {
		is Event.EmailSent -&gt; {
			view.showEmailSent()
			state
		}
		
		is Event.EmailReceived -&gt; {
			state.copy(emails = state.email + event.newEmail)
		}

                // ...
	}
```

U6AH7SUH5 : but it just feels so wrong to call functions on the view directly
U4872964V : If you are to have the Elm architecture, your reducer would also return something like the Elm Cmd
U4872964V : which could be “show the toast” for instance
U6AH7SUH5 : that would at least make it pure, but at the same time introduce even more boilerplate event classes
U4872964V : well, it’s hard to take “half” the architecture I suppose :slightly_smiling_face:
U4872964V : how do you handle fetching data for instance
U4872964V : let’s say i want to click something and then it should fetch me some data
U0CLDU8UB : I suppose you're looking for something more like the Redux side-effect libraries, and not really the Elm way?
U0CLDU8UB : (This is not a criticism, mind you, it might work out better in an OO language like Kotlin)


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
