```
Elswhere in your code, you can import the `Dollar` _type_, but you don't have access to the `Dollar` _constructor_
that means you can't pattern match or otherwise reach into the internals
so `type Dollar = Dollar Int` not equivalent to `type alias Dollar = Int`?
correct
with the `type alias`, `Dollar` and `Int` are equivalent
`Int` is the constructor for Dollar
in `type Dollar = Dollar Int`
`5` is both a `Dollar` _and_ an `Int` because they are aliases for each other (with the type alias)
How would I use the `Dollar` type in the `Dollar` module? And why are opaque types useful?
er - how are they usefule
you can change the implementation without breaking code
for example, say you changed `type Dollar = Dollar { dollar : Int }`
Wouldn't that change how it's used?
Since you couldn't ever reach inside of the `Dollar` type in your code, this won't break for you because you aren't depending on the internal implementation
i think i need to see an example of it being used in a different module
Sure
`import Dollar exposing (..)` then what
