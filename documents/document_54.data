U4VDXB2TU : <@U050MP39D> was trying to not spam the channel with too much code. Any easy way to keep the composability of transducers but stay lazy and fast?
U11BV7MTK : don't enter newlines? i'll bet the autoformatter takes care of it for you
U050MP39D : if the situation/algorithm benefits from laziness my first instinct is to say "don't use transducers there"
U5LPUJ7AP : doesn't look like it <@U11BV7MTK> , there's an option to auto-wrap at the 80-columns limit but i don't want that for code, i will ask in the cursive channel
U4VDXB2TU : <@U050MP39D> is non-laziness inherent for transducers or is it just the way I use them?
U050MP39D : I believe so, one of the reasons that they're faster (in situations where laziness isn't a benefit) is because they don't have the overhead of keeping track of unrealised computations
U051SS2EU : it's a lot simpler to enumerate the things that are lazy (there's very few), and sequence is the only built in lazy thing using transducers and I forget the details but saw it explained that sequence was sub-optimal in important was compared to other lazy functions
U051SS2EU : a transducing function just transforms a single result, so would hardly benefit from laziness, a transducing context can be lazy or not (and sequence is the only lazy built in transducing context)
U4VDXB2TU : <@U050MP39D> <@U051SS2EU> thanks, I will go back and meditate some more on transducers and laziness…
U066TMAKS : is there a way to access the value of the default ring memory store atom from the repl?
U46LFMYTD : ```(* 3 (/ 1 3))
=&gt; 1N
```
I am confused why I would get a BigInt here

U46LFMYTD : is there a design choice which made the return value a BigInt and not an Int?
U1LCB75M2 : <@U46LFMYTD> ```user=&gt; (type (/ 1 3))clojure.lang.Ratio```

U1LCB75M2 : and `Ratio`  is defined in terms of `BigInt` <https://github.com/clojure/clojure/blob/f572a60262852af68cdb561784a517143a5847cf/src/jvm/clojure/lang/Ratio.java#L23>
U46LFMYTD : ah ok, thank you
U2FBZ33M3 : <@U5LPUJ7AP> ```#_(this s-exp will be entirely ignored)``` ?
U5LPUJ7AP : <@U2FBZ33M3> yes, someone told me about that macro, thanks anyway
U2FBZ33M3 : Didn't realise where my scrollbar was at the time, too early :wink:
U1YTUBH53 : Any book (or blog) recommendation, specifically for clojure concurrency?I've spent some time today wrangling atoms, agents, `add-watch` and promises, for managing a work queue. It has been a nice drill. I'm undecided what's the best queue management technique and might suspect clojure.async or even some Java implementation might be more performant/safe.

U1YTUBH53 : Maybe someone's written a book I'm not seeing about that?
U1YTUBH53 : :slightly_smiling_face:
U5JEJN1CP : <@U2MPUENUC> Thanks.  That second did the trick.


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
