U0NGNUH4J : Hello, community! :smile:
I’m building a simple product library to experiment with “making impossible states impossible”.

As the model suggests products can be simple one-off things or a group of products.

*Question*: I have a problem with naming collisions and feel like I’m running out of names. Any ideas about what could be done with the types here?

```
type alias Model =
    { products : List ProductType }


type ProductType
    = Product
    | ProductGroup


type alias Product =
    { name : String
    , price : Float
    }


type alias ProductGroup =
    { name : String
    , firstProduct : Product
    , otherProducts : List Product
    }
```

U5J0H2NS2 : I used to name the type aliases (constructors) like ProductConstructor
U5J0H2NS2 : your type should be something like
U5J0H2NS2 : ```type ProductType
  = Product ProductConstructor
  | ProductGroup ProductGroupConstructor
```

U3SJEDR96 : I think I'd actually go for something like
U3SJEDR96 : ```type ProductInfo = { name : String, price : Float }

type Product
  = Product ProductInfo
  | Group String (NonEmptyList Product)

type alias Model = List Product
```

U0NGNUH4J : ahaa
U5J0H2NS2 : your original ProductType is only an "Enum"
U3SJEDR96 : well, `NonEmpty` actually, using mgold/elm-nonempty-list
U0NGNUH4J : I see
U0NGNUH4J : ```type ProductInfo = { name : String, price : Float }
```

U0NGNUH4J : supposed to be a type alias?
U3SJEDR96 : urhm, yeah
U0NGNUH4J : :+1:
U3SJEDR96 : I wish slack would give me compiler errors :stuck_out_tongue:
U0NGNUH4J : hehe
U0NGNUH4J : Thanks for feedback!
U0NGNUH4J : I will experiment some more
U0NGNUH4J : How about something like this:```
model : Model
model =
    { products =
        [ Single (Product "Orange Juice" 20.0)
        , Group "Pies" (Product "Lemon" 10.0) [ Product "Blueberry" 10.0 ]
        ]
    }


type alias Model =
    { products : List ProductType }


type ProductType
    = Single Product
    | Group String Product (List Product)


type alias Product =
    { name : String
    , price : Float
    }
```

U0NGNUH4J : I agree a non-empty list would be more clear but it’s interesting to see what one can do with “just the language itself”
U3SJEDR96 : yeah, makes sense - and that's basically how I'd initially do it, too. Although I'd probably go "I just want to express a non empty list!" at some point, and then make a `type alias NonEmpty a = (a, List a)`, or go totally overboard with making that a compile-time constraint..
U3SJEDR96 : <https://ellie-app.com/3GddyCVzMtMa1/0> like that. Quite pointless in normal use, but fun to play around with
U3LT1UTPF : Has anyone used *Semantic-ui* with Elm? I just love that framework, but I don't know whether it would be too much trouble.
I'm trying to decide what to use to style my app...

U4872964V : <@U3LT1UTPF> if you haven’t looked into <#C4F9NBLR1|style-elements>, do that :slightly_smiling_face:
U0JS9PAAY : I’ve moved to bulma eventually
U0JS9PAAY : from semantic
U3LT1UTPF : <@U4872964V> :+1::skin-tone-2:
U3LT1UTPF : <@U0JS9PAAY> Why?


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
