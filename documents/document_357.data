```
when you define a type alias, it also gives you a constructor for free. so with your type alias you can call `Macro2 "string1" "string2" "string3"` to build a record
when you define a union type, the "options" are also constructors to build the actual type
so you can't have a union type and a type constructor with the same name in the module
you can move one or the other to another module and call it with the whole name
<@U3LUC6SNS> ^
<@U3LUC6SNS> you'll need something like `oneOf [ parser1, parser2, parser3 ]`, so in your case `oneOf [ macro1, macro2, environment ]` etc
Thanks <@U3SJEDR96>, thanks <@U1ZFF0E5P> !
assuming that `macro1 : Parser Latex` etc
Got it!
Oops, I guess I don't understand --  if I define `type Latex` in a module A importing the module B where `Macro1` etc  are defined, then the `Latex` will be undefined  in module B.  No?
