```
Psycopg2 has a `NamedTupleCursor`, which provides the same syntax.
In that case, at least the schema is documented elsewhere. But I don't like it.
You prefer that?
Maybe
I can work like that. You have a job for me? :stuck_out_tongue_winking_eye:
In the general case, yes. It's not exactly a great hardship. In a database context, it might be nice to have a type that directly reflects the DB schema - which is what we have ORM for
btw, the `NamedTupleCursor` gets its attribute names from the fields behind the *SELECT*. I.e. `select name, salary from Employees` would result in *.name* and *.salary* attributes on the tuples in the resultset.
I just really dislike things that attempt to cut down on a bit of typing by ruining the interface. Several parsers do it, like BeautifulSoup. lxml.objectify is even worse
I wouldn't call it ruining. It makes the code more readable to me. I prefer dot notation over index lookup with a string.
The dot notation and the index lookup carry different information. `x.y` implies that `y` _must_ exist. `x["y"]` implies that a value for "y" might exist, if someone added it earlier.
Except xml node is not a container, but an object :confused:
Ah, we have a different view on that too. When I see `x["y"]` in code, I assume the programmer knows that an *y* value is present, or should be present (punishable by KeyError). When I see `x.get(y)`, then I know the programmer is trying to communicate to me that *y* perhaps does not exist in *x*.
it's an object that contains an arbitrary number of other objects
<@U5ZPMJA06>  But the point is that you see it's a dict, and that the contents vary
Obviously you can make assumptions if you know what's been added, but the syntax tells you the nature of the structure you're working with
<@U5LNXQHN3> Yeah there you have a point, `x["y"]` certainly conveys that *x* is a dict.
...or at least a mapping type on which you can do indexed lookups.
Now wouldn't it be fun to override `__getitem__()` to call a memberfunction instead of looking up a value, and have `__call__()` lookup an indexed item?
You could write `a["save"]` to call functions and `a("age")` to lookup values.
:joy:
I'm trying to use Pycharm CE with Flask but I can't seem to configure a interpreter to run `virtualenv/Scripts/flask` or `python -m flask run`. Is there anyway to run Flask applications inside Pycharm without having to buy the pro version?
<@U63VCB8AH> I believe you just need to set the interpreter to the virtualenv Python, then in the run panel you use flask as the script
That's not an exclusive pro feature as far as i know
How would I reference flask as the script?
<@U1BP42MRS>
<@U1NSCAY6R> not possible
Send a pic of what you see
I'm also stuck on Windows...
What does that have to do with the pycharm config?
Send a pic of your pycharm window
The config
Default, which points to my main.py
Ignore the script parameters, it was just me playing around
Script should point to flask from the virtualenv, if you're in one
Flask is the script/executable
in `env\Scripts`?
`which flask` would show the path on posix
yes that's right
but I can't use that in Pycharm since it is an EXE file
Then be sure to set the working directory in that same window to the project root (where main is)
On mobile, I'll check back when I get to my office
Windows BS
one reason I suggest using a virtual machine
eg, docker or vagrant
anything other than java or C# on windows is more trouble than its worth, in my experience
agree <@U0LSCQQNR>
I have Flask running just fine in PyCharm on Windows. Not at the machine now, though.
Community Edition <@U5LNXQHN3> ?
No, but I don't expect it matters
Pro set's everything up automatically, used it at my last job
I never use automatic setup. I would have done it manually
I just filled in the fields as in Joe's screenshot
do you remember what use set the Script file to?
No. I might just have a file which contains `app.run()`.
Apparently that's not recommended any more, probably because it doesn't play nicely with other aspects of Flask that I'm not a fan of
kylotan: not a fan of many things
:slightly_smiling_face:
Only with flask
it is true, I'm pretty unhappy with most software I work with
haha
i'm sticking with `app.run()`` for now
'r--', 'bs' and 'g^' indicate color and shape. example: 'g^' stands for green triangles.
Best way to approach calling function using a dictionary to store the func object as a value. I'm doing this in a class so it doesn't quite work properly the traditional way of literally just using the function object name as the value.
