U051HUZLD : is there something builtin or better for this?```
(defn least-common-ancestor [path1 path2]
  (let [i (min (count path1) (count path2))]
    (reduce
      (fn [p idx]
        (let [v1 (nth path1 idx)
              v2 (nth path2 idx)]
          (if (= v1 v2)
            (conj p v1)
            (reduced p))))
      [], (range i))))

(least-common-ancestor
  [:a :b :c]
  [:a :b :d])
=&gt; [:a :b]
```

U051SA920 : <@U051HUZLD> `(take-while some? (map (fn [a b] (when (= a b) a)) [0 1 2] [0 1 3]))`
U3HKE2SLW : This one has much better runtime performance, mostly stemming from the omission of `nth`
U051HUZLD : :bellissimo:
U051SA920 : Well you could avoid one `nth` call here if you use `reduce-kv` and you can guarantee it's a vec
U051HUZLD : not worth it. on the other hand, count being &gt; 10 is highly unlikely (in my case).
U051SA920 : Yeah then the `map` version will be quicker. Reduce is often slower for smallish input
U051SA920 : And if you want to avoid the intermediate sequence: `(sequence (comp (map #(when (= %1 %2) %1) ) (take-while some?))   [0 1 2] [0 1 3])`
U051HUZLD : <@U051SA920> on such small inputs it is not worth it:```
(time  (dotimes [n 1000]    (take-while some? (map (fn [a b] (when (= a b) a)) [0 1 2] [0 1 3]))))
"Elapsed time: 1.166446 msecs"
(time  (dotimes [n 1000]    (sequence (comp (map #(when (= %1 %2) %1) ) (take-while some?))   [0 1 2] [0 1 3])))
"Elapsed time: 7.258858 msecs"
```

U051SA920 : <@U051HUZLD> Don't forget a `doall` :slightly_smiling_face:
U051HUZLD : ```(time  (dotimes [n 1000]    (doall (take-while"Elapsed time: 3.356031 msecs"```

U051HUZLD : :opieop:
U051HUZLD : omg what am I doing right now?
U051SS2EU : if you want to measure calculation time (or run for side effects) and don't need the result, use dorun instead of doall
U051SS2EU : also, sequence is not typically more efficient than regular lazy ops in most cases iirc
U051SS2EU : I'd start with the general concept of event sourcing, which is more general and more usable than CQRS
U5ZAJ15P0 : <@U051SS2EU> right, sorry, I think my question was misphrased. Right now I am more concerned about how to structure my code at the application level (how to organise functions and manage side effects)
U051SS2EU : event sourcing is a strategy for this
U5ZAJ15P0 : Datomic already gives me some level of event sourcing, which is enough for my needs
U5ZAJ15P0 : ah
U5ZAJ15P0 : how so <@U051SS2EU> ?
U051SS2EU : the concept is that events are immutable and describe the actual domain data
U051SS2EU : then, your db describes state, and is created via a reduce across the events (literally or conceptually)
U5ZAJ15P0 : <@U051SS2EU>  i mean, I am familiar with what event sourcing is, but I don't see how it would help with this
U051SS2EU : because now your state is just a query across your events
U051SS2EU : it's an optimization
U051SS2EU : so you have "all events", from that you derive a postgress db, or a datomic db, or even a mongo db - via looping over the events, maybe with reduce
U051SS2EU : that's your state of the world
U5ZAJ15P0 : Right, but Datomic already gives a fairly event-sourced model (except that transactions dont' represent domain actions, but they can be reified with a key that does represent a domain action)
U051SS2EU : now, if your events are set up properly (strictly ordered, immutable) - all instances of your app have access to the same time series of immutable states
U5ZAJ15P0 : Datomic's transaction log can be considered as the event log
U051SS2EU : queries are reads of the current state, "modifications" are insertions into the stream of events (you must loop back up to that level)
U051SS2EU : right, right
U051SS2EU : so you are on the right track if using datomic, you don't need CQRS for this
U5ZAJ15P0 : My concern is more: how do I nicely separate my "business logic" (functions that perform transactions, authorisation and reify transactions with additional infos) from my API
U5ZAJ15P0 : in the application code
U5ZAJ15P0 : sorry if this wasn't clear
U051SS2EU : I use protocols to describe my domain / API level abstractions
U5ZAJ15P0 : what should the interface for those functions be to make them easy to think about and deal with, etc
U051SS2EU : then for my implementation, I use functional code over vanilla data structures implementing those protocols
U051SS2EU : the protocols are used as a signal to a reader of the code / user of the library that these names describe domain level concepts, they are the big picture organization of the code
U5ZAJ15P0 : do you have an example of this structure?
U051SS2EU : I'll have to see if I have a good open source implementation of it…
U5ZAJ15P0 : so protocols are your "public API", and all other functions are implementation details
U051SS2EU : right - and the protocol methods are expected to take and return hash maps, vectors, keywords, numbers
U051SS2EU : so we don't pile on mountains of OO, we use modeling tools on the boundaries as a line in the sand, so to speak - to declare organizational intention
U5ZAJ15P0 : how do you pass context around (db, conn and auth)? and how do you perform authorisation / reified transactions, if you do so?
U051SS2EU : I use component, so that each subsystem gets the parts of the app that it needs passed in on initialization
U5ZAJ15P0 : Could you give me a example of a protocol definition you use in one of your apps?
U051SS2EU : absolutely - found it!
U051SS2EU : protocol definition <https://github.com/noisesmith/ludic/blob/master/src/clj/org/noisesmith/ludic/protocol.clj>
U051SS2EU : implementation <https://github.com/noisesmith/ludic/blob/master/src/clj/org/noisesmith/ludic.clj>
U5ZAJ15P0 : and brilliant, thanks!
U051SS2EU : oh man - that project is in a slightly weird state, there's two GameBoard protocols that should have different names, and some protocols that need to be moved to the proto namespace
U5ZAJ15P0 : if those functions were hitting a database, would your record hold its ref?
U051SS2EU : sorry ! it's still in heavy development
U051SS2EU : the record would expect the ref, yes
U5ZAJ15P0 : Mmh
U5ZAJ15P0 : And if I want to reify *every* transaction with, say, the access token of the current user, how would you do this? Would you provide your own "transact" function, wrapping Datomic's?
U5ZAJ15P0 : Sorry for the messy questions
U051SS2EU : that's a usage of reify that doesn't match what I thought the word meant
U051SS2EU : do you mean parameterize? I thought reify meant "make an abstract thing into a concrete one"
U5ZAJ15P0 : I thought that's a usage I read in the doc
U5ZAJ15P0 : I might be mis-using the term
U5ZAJ15P0 : <http://blog.datomic.com/2015/12/reified-transactions.html>
U5ZAJ15P0 : I should have said "add an attribute to the reified transaction"
U051SS2EU : ahh! now I get it, thanks
U051SS2EU : so yeah, I would make an object that represents that reifications including the user id
U051SS2EU : this is getting deeper into datomic than my working knowledge of it - I've taken a workshop but not gotten far with it in real usage
U5ZAJ15P0 : <@U051SS2EU> haha ok, no worries. In general though, would you consider it "good code" if I wrapped all access to Datomic inside a protocol (e.g. IDatomicReaderWriter or something) so as to control how every transaction is made, and add some data to the transactions as I see fit?
U051SS2EU : I'd first see if this is an abstraction datomic itself allows
U051SS2EU : unless your goal is to be able to swap in another database (which probably means forgoing a bunch of the features that make datomic worth it?)
U051SS2EU : I wouldn't bother abstracting things that pragmatically wouldn't be worth replacing ever
U5ZAJ15P0 : I wouldn't want to swap out Datomic. The only thing I would want is "intercept" calls to `datomic/transact` to add some data to the transactions
U5ZAJ15P0 : e.g. add the "current user id" as an attribute on the transaction
U051SS2EU : I'd say make your own function over transact that adds the data, probably parameterized with a hash map so you can generalize and introspect
U5ZAJ15P0 : so that I don't have to do this manually everywhere I call `datomic/transact` in my application
U5ZAJ15P0 : ok; thanks!
U051SS2EU : one thing to avoid is opaque wrappers (whether partial or an Object with hidden state - which btw is what a partial or closure is) - use a record implementing datomic's own protocol if possible, but parameterized by keys you can introspect on the record and access in context
U5ZAJ15P0 : <@U051SS2EU> is there a repl command to get the list of all protocols implemented by an object?
U5ZAJ15P0 : well, the record of which an object is an instance
U051SS2EU : supers
U5ZAJ15P0 : ah right because protocols are just interfaces
U051SS2EU : oh, supers needs the class, but that's easy enough
U051SS2EU : ```=&gt; (supers (class {}))#{clojure.lang.IKVReduce clojure.lang.IFn clojure.lang.IMapIterable java.io.Serializable java.lang.Object clojure.lang.IObj clojure.lang.IMeta java.lang.Runnable clojure.lang.MapEquivalence clojure.lang.IHashEq clojure.lang.ILookup clojure.lang.IPersistentMap clojure.lang.Counted clojure.lang.IEditableCollection clojure.lang.Associative java.lang.Iterable clojure.lang.IPersistentCollection clojure.lang.AFn java.util.Map java.util.concurrent.Callable clojure.lang.Seqable clojure.lang.APersistentMap}```

U5ZAJ15P0 : ```wef-backend.core=&gt; (supers (type (get-conn)))
#{#&lt;Class@35fc6dc4 java.lang.Object&gt;
  #&lt;Class@e7b265e clojure.lang.IType&gt;
  #&lt;Class@6b337969 datomic.Connection&gt;}
```

U051SS2EU : cool - so you can make a defrecord that implements Connection - the others come free with defrecord
U5ZAJ15P0 : is Connection a protocol there?
U051SS2EU : this is the point where I end up reading source code usually, heh
U051SS2EU : I bet it's documented … somewhere
U5ZAJ15P0 : I'll look into it. Thanks :slightly_smiling_face:
U5ZAJ15P0 : <https://gist.github.com/robert-stuttaford/39d43c011e498542bcf8>
U5ZAJ15P0 : I'll ask <@U0509NKGK> , I am sure he has insights on this
U051SS2EU : cool - thanks for asking about this, I learned a couple of things in trying to find your answer


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
