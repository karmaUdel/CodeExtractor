nthItemWithDefault index default = nthItem index &gt;&gt; Maybe.withDefault default```
I would still suggest that if you need random (nth element) access, then list is the wrong datastructure to use.
there is a reason those methods are not in the stdlib and it's intentionally annoying to use
I find the cognitive overhead of trying to remember which "listy" data structure I'm using isn't worth it. YMWV :slightly_smiling_face:
In our system, we don't have any other listy data structure except `List`
We had a case where we thought we needed random access, but it turned out we really needed a zipper, so we built one on top of `List` :slightly_smiling_face:
precisely my point
But, of course, context rules
I'd probably say "if you need a random access data structure, you might look at whether you really do" :slightly_smiling_face:
especially for beginners, I'd say "stick with the list!"
IMNSHBCCO
It could be that you need a dict instead
also
Then the complexity around `Dict` needing comparable comes in. :slightly_smiling_face:
I'm pro-OnlyList ! :slightly_smiling_face:
fair enough, I'm just saying its worth thinking about whether that's actually the data structure you want. If only so you sit down and force yourself to think about the structure of your data
True, true. :slightly_smiling_face: I look at <#C192T0Q1E|beginners> and think "just use list!" :slightly_smiling_face:
I think of <#C192T0Q1E|beginners> as beginners to elm but not necessarily programming, but I could be wrong.
I think it covers all. but, a lot of people come in here from javascript, so there are implications from that on expectations around lists/arrays/dictionaries/etc
Breaking those can be good.
when moving into a language like Elm
Which is why i tend towards "if you think you need random access, you probably don't"
sure, I can agree with that
But, in the end, :heart_eyes_cat: for every piece of friendly, welcoming advice that people give here
That's the most important thing
Because, in the end, whether you use array or list, WELCOME TO ELM! is a pretty consistent message I see here. I :heart: that!
:stuck_out_tongue:
`button [onClick (&lt;funtion&gt; &lt;model&gt;)] [text "blah]`
function no, it dispatches a message with which you can do something with
Alright. Just was curious if there was another way. Thanks <@U23SA861Y>
you can however run a function against the model and have the message get dispatched back with the result
Can anyone point me to an example of how to use Json.Decode.Pipeline to decode a field  defined as a union type?
oneOf is the function you want I believe
Ah, ok. I just found an example using that.  Thanks!
