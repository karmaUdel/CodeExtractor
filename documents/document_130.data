``` I don't know if it's cider, but something's misbehaving
...ah, it didn't compile and didn't say anythign
oh - right-  macroexpand silently outputs a form that doesn't start with a known macro
even if the thing in it isn't defined
Back to the drawing board, I guess. Apparently I'm still too dumb to do macros.
Cider magic introduces ambiguities and special cases about what's been evaluated and what hasn't, it's an easy mistake
and macroexpand doesn't care if the things inside it are known, it just expands known macros and leaves the rest alone
Ok so it expands with `C-x e` in the editor, but not in the REPL, which is set to be the same ns. Huh.
Heh ^^ But I wouldn't want to miss it. It's weird, but it's great.
...like Emacs, I guess :stuck_out_tongue:
`C-x e` by default is for calling a keyboard macro inside Emacs, and I think the default binding for expanding a clojure macro is `C-c RET` which works for me from the REPL as well
`C-c RET` for `cider-macroexpand-1` and `C-c M-m` for `cider-macroexpand-all`
Ah. So `clojure.core/macroexpand` isn't expected to work in the CIDER REPL?
oh right you are typing it in the REPL, let me try that
exactly
I get the same result as <@U051SS2EU> when typing it in the REPL
It simply returns the input for me on the REPL, but works fine when evaluating with C-x e in the editor
But `C-c RET` is a more-than-worthy REPLacement anyway
what is `C-x e` bound to for you?
The default, that is evaluating the expression at the cursor
perhaps you mean `C-x C-e`?
Ah, yes, right.
it works for me the same way regardless of whether I type it or evaluate the form in a code buffer or in the REPL
I'm not on the latest version however, so perhaps something changed, anyways this should probably belong to <#C0617A8PQ|cider>
