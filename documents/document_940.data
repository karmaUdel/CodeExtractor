U0702F2CE : I won't have time
U0702F2CE : But I ran some tests and checked them off
U3P6ZDH60 : <@U3NP867S6> indeed I added deps yesterday. Did I do something wrong?
U3NP867S6 : <@U3P6ZDH60>: I don't think so? A pre-release pkg-build (see link from samth above) that happened before your changes had some deps errors. Your changes may have fixed them.
U3NP867S6 : But we'll have to wait for the next pre-release pkg-build to know for sure.
U3P6ZDH60 : Oh, okay, I think I fixed them. Cheers!
U3NP867S6 : :)
U07SJGB4H : Would it be bad to spawn a thread in a plumber flush callback that frees some resource and not wait on the thread before removing the flush callback registration? Could racket exit after the plumber is flushed but before the background thread finishes?
U3NJS8H7C : <@U07SJGB4H> Yes, Racket could exit before the thread finishes
U6580B1UM : is there a way to define something once and have it be available in both the for-syntax and the top-level without copying and pasting?`(begin-for-syntax (define my-fn my-fn))`
is the dumb first thought that comes to mind, and obviously that doesn't work. (If it did, I would be surprised.)
(edit: where my-fn is already defined, of course)

U462H29AR : <@U6580B1UM> You can define the thing in a module, then `require` the module both for runtime and `for-syntax`.
For instance using `module` in the same file:
```
#lang racket

(module m racket/base
  (provide f)
  (define (f)
    (println "f")
    42))

(require (for-syntax 'm)
         'm)
```

U462H29AR : Or you could define `f` in a module that is another  file like `f.rkt`, and `(require "f.rkt" (for-syntax "f.rkt"))`. Same difference.
U6580B1UM : gotcha, thanks <@U462H29AR>
U462H29AR : <@U6580B1UM> You're welcome.  The TL;DR is define things once in a module. Then, how/when they're available is a function of how you `require` their module.
U08JL5H89 : <@U3NJS8H7C> How often do we update the versions of various native packages?
U08JL5H89 : As listed here: <https://github.com/racket/racket/tree/master/racket/src/native-libs>
U08JL5H89 : I ask because I would like to know if I can rely on Racket coming with libpng16. (Except on Linux obviously.)
U3NJS8H7C : Rarely, and on no particular schedule
U08JL5H89 : That makes sense. Do we have any announcement when we do?
U08JL5H89 : I mean, I would be happy to have racket install libpng16 when its needed. But I'm worried about that conflicting with the one Racket comes with.
U08JL5H89 : I guess, since its not going to update in the middle of a Racket version, I can just make a libpng16 package, and have an exception to not install libpng16 for versions that already have it installed.
U3NJS8H7C : We provide libpng16 right now on Windows and Mac OS, right?
U08JL5H89 : That is correct.
U08JL5H89 : And on linux it needs to be installed (which it is on basically every distro….)
U6580B1UM : I've having trouble with the `str` syntax class (or, at least I think I am...?): I have a custom syntax class that uses `str` in its pattern, but when I give it a str in the correct location it fails to match, even though the output of `(string? (syntax-e stx))` is #t.
I made a gist of the issue in an effort to make up a minimal reproduction: <https://gist.github.com/fluffywaffles/e616df5399d5e7140b76229af94b30d0>

Any help would be much appreciated! I have absolutely no idea why this is happening.

U07SCV14J : <@U6580B1UM> It looks like the `q` class matches a string, but the last subform provided to select is a list containing a string.
U6580B1UM : Right; I explain that I still think the error is unexpected... Can you explain why it does what it does?
U6580B1UM : In the gist, rather, I explain in a comment (on the gist, not in the code)
U07SCV14J : I think you'll get the behavior you expect if you add the `#:commit` option to the `q` syntax class.
U07SCV14J : Unfortunately, I have to run—maybe someone else can explain in more detail (or I can once I get back).
U6580B1UM : that works -- thanks <@U07SCV14J>
U6580B1UM : I don't know why, but it works
U07SCV14J : I have another minute or two… basically, without `#:commit`, syntax-parse can backtrack back _into_ a syntax class even if the syntax class originally succeeded if a later parse fails.
U07SCV14J : So your `q` pattern successfully matches `"hello"` against the first pattern, then continues matching the top-level pattern, and that fails. So it backtracks into `q` and tries to match `"hello"` against the second pattern, which always fails.
U07SCV14J : And specifically, it fails by throwing an exception, not by using `~fail` or something like that, so that failure is unrecoverable, and parsing halts.
U6580B1UM : oh, interesting -- so if the first syntax class pattern matches, but then after moving on, the next form in the overall syntax object doesn't match, it'll go back to the most recently tested syntax class and try other patterns?
U6580B1UM : Why is that?
U07SCV14J : You probably want to use `~fail` instead of `(~do (raise-syntax-error ...))`. Of course, in this case, you probably don't want the second case at all, and instead might just want to add `#:description "question"` to `q` and just let syntax-parse generate its own error message.
U07SCV14J : But yes, generally, syntax-parse tries _everything_. It backtracks to try every possible solution unless you explicitly add cuts/commits.
U07SCV14J : It's possible to construct a situation in which that backtracking behavior is desirable, but it often isn't, so `#:commit` is a useful option for a lot of syntax classes.
U07SCV14J : Unfortunately, I don't have time to construct such an example, though.
U6580B1UM : No, you've been plenty helpful even without! Thanks <@U07SCV14J>
U07SJGB4H : <@U6580B1UM> The "try everything" approach is also paired with a notion of "progress" - syntax-parse orders possible parses based on how early they fail. When parsing fails, this lets syntax-parse choose the parse that failed the latest and uses that parse for an error message, since that's likely what you want. The "Introduction" section of the syntax parse docs describes this and other aspects of syntax-parse in a friendly manner, I recommend reading it: <http://docs.racket-lang.org/syntax/stxparse-intro.html?q=syntax%20parse>
U08JL5H89 : You can use the #:version keyword to specify a min version. Is there any easy way to specify a max version?
U07SCV14J : Not only is there not an easy way, there is no way at all.
U08JL5H89 : <@U07SCV14J> Hmm…welp lol
U08JL5H89 : Looks like I'll have to catch that at runtime instead then. That sucs.
U08JL5H89 : sucks*
U08JL5H89 : (And is also _really_ bad. :confused: )
U07SCV14J : The correct policy, according to the current package system policies, is to never break backwards compatibility. That way, there's never any reason to have a max version.
U07SCV14J : I make no comment on whether or not I find that policy reasonable.
U08JL5H89 : Ya….that's not ganna fly.
U08JL5H89 : FFmpeg, for example, WILL break backwards compatibility, on major version updates.
U08JL5H89 : (Minor ones will only add functionality, not breaking anything.)
U08JL5H89 : As such, the only thing I can think of is to make a ffmpeg package for every version.
U07SCV14J : Then, according to the current package system policy, you should make a new (Racket) package for each breaking version of FFmpeg.
U08JL5H89 : Well fun.
U07SCV14J : See section 10.5 of the package documentation. <http://docs.racket-lang.org/pkg/FAQ.html#%28part._.How_can_.I_specify_which_version_of_a_package_.I_depend_on_if_its_interface_has_changed_and_.I_need_an_old_version_%29>
U08JL5H89 : Welp great.
U08JL5H89 : So basically the official policy is to flood the package server with slightly different versions of ffmpeg.
U08JL5H89 : (whenever they break compatibility anyway.)
U08JL5H89 : I guess at worst, it'll be ~200 packages.
U3SEVDPJT : I'd been thinking about the current package policy, I was wondering if it would be feasible to layer a protocol on top of the current package system. Create a package of packages, a "meta-package", give it a canonical name, and each package in the meta-package would represent a major version with minor versions being kept within each package.
U3SEVDPJT : I'm not sure how feasible that idea would be and whether the current system can be hacked in that fashion.
U462H29AR : I mean, as _users_ of packages I think everyone agrees we want them to act like persistent data structures -- only add new capabilities, never take away old ones?
U462H29AR : As _developers_ of packages: There's no shame in saying, well, after making Thing, I realize it should have had a whole other design -- and going on to make Other Thing.
U462H29AR : I think there's some shame in saying, Thing is now a shadow of its former self, and will suddenly break things. And transitively break things.
U462H29AR : I'd love to see us stick with this idea(l) as long as we can?
U462H29AR : But I don't know what to do about situations like <@U08JL5H89> trying to wrap or use something that is rampantly mutating its interface with contract-busting major versions.
U086VDRBK : Have thing1, thing2, ..., thingN  and then have a bonus package named thing that just reexports  thingN ?
U3SEVDPJT : <@U462H29AR>, I'm sympathetic to that idea, it is frustrating to manage compatibility breaking issues and I'm interested in seeing how far we can go with one package per compatibility-respecting code , but on the other hand, it would be nice to have some notion of namespace management to handle various versions
U07SCV14J : I strongly believe that Racket would benefit from a more ordinary language package management solution, with version bounds and a constraint solver.
U3SEVDPJT : <@U086VDRBK> yeah that pretty much sums up what I am talking about.
U07SCV14J : I've discussed a little bit about what that would take to do right with… <@U3NJS8H7C> and <@U0702F2CE>, IIRC?
U07SCV14J : But it's been a little while.
U3SEVDPJT : Would that be possible to reexport packages through one package?
U086VDRBK : <@U3SEVDPJT>  If I recall correctly, there were a discussion on the mailing list (about the time the new package system arrived)
U3SEVDPJT : yes, I do recall that as well, I read all of correspondence that got generated when the new system was released, I'd have to go back and review to see if any viable ideas were proposed
U07SCV14J : FWIW, I thought about adding a metaprotocol of sorts on top of the existing package system, but since then I've realized it would probably be easier to just extend the package system to add more metadata to packages and features to `raco pkg`.
U3SEVDPJT : yeah, I'm in agreement, it seems it'd be easier to just extend the system, most of the ideas to date can be categorized as "adding more metadata" and have better metadata aware tools.
U07SCV14J : So, my current understanding is that there would need to be four changes to get the package system to where I want it to be. (1) Packages need to become a mapping from package name *+* version to package sources, instead of just package name. This can be added by adding more metadata to the existing package protocol. (2) Packages need to be able to specify version ranges in their `info.rkt` files. (3) `raco pkg` needs to be extended to do constraint solving when installing packages. (4) Racket needs support for package "sandboxes” a la Cabal sandboxes, Bundler environments, or Python virtualenv, so that multiple versions of a package can be installed on the same machine without breaking everything.
U07SCV14J : None of those things are anywhere near new research, but they are still a lot of work.
U462H29AR : Should there also be Scribble enhancements -- so that as well as "added in version x" you can say "taken away in version x" or "gratuitously changed in version x"?  I am mostly but not entirely joking. :slightly_smiling_face:
U07SCV14J : I think so! Having better tooling support for deprecations would be good, too.
U3SEVDPJT : or available in #lang version4.5
U3SEVDPJT : though that probably would be an abuse of the lang system!
U07SCV14J : Well, to be clear, my vision does _not_ involve installing multiple versions of a package at the same time, or specifying versions in imports a la PLaneT. There are various reasons why you want to decouple version specification from module imports.
U462H29AR : Are these versions a new dimension by which we multiply the `{-lib -doc -test}` packages, too?
U3SEVDPJT : <@U07SCV14J> your understanding seems spot-on and is what I was thinking too. The package sources are already uniquely identified by the package checksum so it would be a simple mapping from name to the checksum.
U07SCV14J : <@U462H29AR> No, not in the sense that they would take up multiple spots in the package index. Think closer to a generalization of version exceptions.
U3SEVDPJT : <@U462H29AR> I would consider those packages to be "satellite packages" and grouped together
U07SCV14J : There are a lot of other changes I would ideally make to Racket's package system if we could start from scratch, including a way to subsume the lib/doc/test split, but those things are far harder than anything I mentioned so far, since they would involve more fundamental changes to how Racket internally treats modules and module loading.
U07SCV14J : The package system is currently designed in such a way that the core of Racket knows effectively nothing about packages. Packages just extend collections, and Racket only knows about collections.
U07SCV14J : There are downsides to this, though, such as the fact that it's impossible to resolve conflicts in the case where multiple packages provide modules at the same path.
U07SCV14J : (And that includes multiple versions of the same package, in the proposed system.)
U462H29AR : If the pkg mgr could handle modules (for the lib/doc/test purpose), it could handle modules like api1, api2 ... and _that_ feels better to me than arbitrary version numbers and disappearing interfaces.
U07SCV14J : I don't think you want multiple versions to be distinct packages because you really want to be able to depend on version ranges.
U462H29AR : But I don't care about version ranges. Those are a proxy for capabilities, which I do care about. :slightly_smiling_face:
U462H29AR : I'd rather say, "I need api-that-gives-me-foo, and the docs, but not the tests", for example..
U3SEVDPJT : I'm not sure if changing module treatment and loading would be good idea, at the end of the day, the packages are being combined to create a set of collections that are available for Racket to load.lib/tests/docs don't necessarily need to be handled specially at the module level.

U3SEVDPJT : Indeed, I feel would rather have a capability that points to specified set of interfaces and dependencies, instead of harder to understand version numbers.
U3SEVDPJT : hmmm, that does seem like a potentially fruitful direction, but I fear it likely need a lot more research before it'd be viable for general community use.
U07SCV14J : <@U462H29AR> You could certainly try and design something much more elaborate than version numbers, but generally some notion of semantic versioning tends to be a good set of compromises to solve that problem.
U07SCV14J : Especially since often you want to break compatibility in a small way, and you want some dependent packages to use conditional compilation to pave over the differences.
U462H29AR : I guess I've logged some time with things like `QueryInterface` in COM, `fboundp` in Emacs Lisp, and `dynamic-require` in Racket.And I've found it preferable (to me) to ask directly for the thing I actually care about.
Than to have a level of indirection looking at hopefully correct docs and change logs.

U462H29AR : If the desired function turns out not to exist, and the pkg versioning theory is "only add", then I can give the user an error message like "Please update to the latest ___", and that's it.  [Edit: Or, maybe gracefully downgrade something.]
U462H29AR : Maybe that's impractical but I stubbornly want to live in a world like that :slightly_smiling_face:
U07SCV14J : For what it's worth, I abandoned the idea of using Racket at work because of the lack of versioning. And I've sort of drifted away from Racket development _in general_ because of it. The burden on package authors to divine a perfect architecture in the first version is far, far too much in a field that strongly benefits from rapid iteration on incremental changes.
U07SCV14J : The strategy of adding an entirely new package for breaking changes isn't good enough, since often the change in question is actually quite small, and you don't want to completely fragment your own ecosystem just to change a small thing that likely won't impact 90% of users.
U462H29AR : Those are great points. And to be clear, I'm definitely in favor of a boolean "I'm ready/willing for other packages to depend on mine" flag, and having the option not to set that until you're ready!
U07SCV14J : The current package policy works okay with very small teams, but I now work in a large organization that needs the ability to move asynchronously and update at their own pace.
U07SCV14J : JS's and Haskell's package systems have supported our needs there quite nicely.
U07SJGB4H : for open source racket the problem is somewhat mitigated by the package-wide continuous build system
U07SJGB4H : but if you're not using that and you write a lot of packages the pain will magnify
U07SCV14J : We have a number of internal packages that break compatibility on a monthly basis, and that's okay, because we publish detailed changelogs and let people upgrade whenever they get the chance.
U07SCV14J : CI can't change the fundamental problem of backwards incompatible changes retroactively breaking code that worked before without changing anything, which is unacceptable.
U07SJGB4H : I didn't say it changed the fundamental problem, I said it somewhat mitigated it
U07SCV14J : I didn't claim you did, but I'm mostly just expressing that these problems are not imaginary, since _I_ have basically ditched Racket for anything "real” because the tooling doesn't support my needs.
U3SEVDPJT : <@U07SCV14J> it's concerning that you weren't able to accommodate the current package system to your organization's needs, that says to me the system needs at least a review. It's been in use for how long as it been? 3-4 years? That's long enough to reassess how successful the system has been and what improvements would be needed.
U07SCV14J : I don't think the changes I mentioned would be terribly controversial; they were formed in a discussion between me and a few other people. Someone just needs to implement them.
U07SCV14J : But that takes time and effort, and currently nobody has enough of that to spare.
U3SEVDPJT : I'm in a position where I'm using Racket at work for small-scale projects, I've yet had the opportunity to seriously use the package system to manage my needs, so it'll be interesting to see how far I'm able to go.
U07SCV14J : One example of something we've done at my organization that has been extremely successful is a Haskell DSL we use for writing deployment scripts. We use Haskell's package versioning system to write self-executing scripts in Haskell (with a relevant shebang), which is pretty cool. Since the scripts express the version they depend on, we can judiciously break backwards compatibility whenever it makes sense, which has let us rapidly iterate without feeling a need for BDUF.
U07SCV14J : I couldn't really do that in Racket, even if it would be a good tool for the job.
U07SJGB4H : How well would a two stage solution work that first added everything except the ability to install multiple versions at the same time? The other three pieces are much easier to implement and might work as a temporary solution.
U07SCV14J : They're mostly independent, but the sandboxing is pretty necessary to avoid inventing Cabal Hell in the Racket ecosystem. Sandboxing is actually mostly implemented, too, so it's actually probably not that much effort to add.
U07SCV14J : If it were a huge amount of work, I would agree with you, but I don't think it makes a ton of sense to skip if you're also going to do the comparatively monumental amount of work to implement the other parts.
U3SEVDPJT : may you point me to where the sandbox environment has been implemented? Is it a raco feature?
U07SCV14J : There isn't really user-facing tooling for it, so the work would basically just be to integrate it with raco, but the infrastructure exists. I can't remember exactly where the relevant features are documented, but the feature is called "tethering”.
U3SEVDPJT : ooh I do remember coming across that term
U07SCV14J : It's alluded to here: <http://docs.racket-lang.org/raco/dirs.html#%28def._%28%28lib._setup%2Fdirs..rkt%29._find-addon-tethered-console-bin-dir%29%29>
U07SJGB4H : An important question is whether implementing it would require help from mflatt, since he likely won't have time to focus on stuff other than racket7
U07SCV14J : I think it could be done with minimal knowledge of Racket internals. A few questions here and there maybe, but I don't see why much of it would involve anything complicated.
U07SCV14J : I would bet the majority of the work would be extending `raco pkg install` to do constraint solving and handle the notion of version conflicts.
U3SEVDPJT : Suppose the four main items are designed and made available in a side-branch of the racket mainline. Would it be able to accommodate the current style of additive changes. Suppose one package favors the additive style and other one takes the version numbering approach. How do we manage users experience so they don't get confused by two different styles?
U07SCV14J : A package could easily just only make additive changes by only ever bumping the minor version.
U07SCV14J : But there would certainly be some tricky migration/compat issues to work out.
U07SCV14J : I don't think any of them are super hard, though.
U3SEVDPJT : and by setting max version to #f indefinitely really
U07SCV14J : IIRC, the proposed compatibility solution was to basically (for now) treat packages specified without bounds as `&gt;=1 &amp;&amp; &lt;2`.
U07SJGB4H : The version constraint solving doesn't sound like the hard part, especially if it's implemented with the aid of a logic programming dsl
U07SCV14J : I don't really mean the constraint solving algorithm itself, but I mean plumbing the inputs and outputs of that algorithm through the rest of the system.
U07SCV14J : You need to set up the infrastructure to make the version information available to the solver and configurable by users. You need to handle all the corner cases of version conflicts and solver failures. You need to present meaningful error messages when the solver doesn't come up with a solution. And you need to implement all of this while maintaining backwards compatibility with the old system.
U3SEVDPJT : indeed oof that sums up the problem.
U07SCV14J : Doing package management right is really hard! I don't know of any programming language that got it right from the beginning, most added it on only after it became obvious how necessary it was. :p
U07SCV14J : (And many langs still have awful package management. Go comes to mind…)
U3SEVDPJT : we just need to find that magic wand everybody keeps talking about.
U08JL5H89 : I agree with <@U07SCV14J> Saying ‘make a new package' whenever you make a breaking change seems fine, until you realize that what is going to happen is that your going to get a package catalog with hundreds of packages per actual package.
U08JL5H89 : <@U3SEVDPJT>  Oh, its in the cellar, let me go grab it.
U07SJGB4H : Plus different users have different ideas of what a breaking change is
U3SEVDPJT : and the current package index is not easy to parse so your own study case is only going to exacerbate it.
U08JL5H89 : <@U07SJGB4H> That too. So….this is why I make a new package for every git commit.
U08JL5H89 : (Or at least every commit I push.)
U07SJGB4H : _Plus_ you can't even tell ahead of time whether a change is going to break any dependents with perfect accuracy!
U07SJGB4H : in a large enough ecosystem someone's always using your thing in a way you never could have anticipated
U07SCV14J : Tbh that's one of the reasons why I think Hackage's ability to edit constraints after publishing a package is a good feature.
U07SCV14J : A lot of tools get unhappy with the notion that releases are not immutable. But otherwise, if you don't have that option, those bad constraints stick around and mess up the solver forever.
U07SJGB4H : a release's content being immutable while its declared relationships to other releases being mutable doesn't sound so bad to me either
U07SCV14J : But yeah. All of Maven, Bundler, NPM/Yarn, Cabal, etc. are tools added long after the lang was invented to solve this problem.
U07SCV14J : I guess maybe Cargo gets this right from the beginning? But Rust is unique in a lot of different ways. :)
U3SEVDPJT : so we have several notions at work here, some set of release source files, versions, canonical names, bundling variants with or without docs, constraints. Need to figure out how to stir all of them into a workable backwards compatible solution.
U3SEVDPJT : the idea of dependency relationships being modified after the release doesn't sound too bad to me either.
U07SCV14J : Racket's package model is more mutable than many, anyway, since the package system doesn't even host the package sources.
U3SEVDPJT : The obvious next step for me is to study other package solutions, see what ideas they overlap in and what work and doesn't work.
U07SCV14J : So a bad actor could just nuke a git repo or push a change to a release tag and cause a lot of problems. But I would not recommend addressing that problem with all of this.
U07SJGB4H : there's a really good blog post about package systems that's helpful for this
U07SJGB4H : <https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527>
U3SEVDPJT : That reminds me of that time when someone blew away their npm contributions and crashed the npm network which had been depending on one small packages released by that author departing with all of his toys.
U07SJGB4H : wasn't that the "leftpad" package?
U3SEVDPJT : yeah that sounds right
U07SCV14J : IMO, the Bundler/Cabal models are a really good set of tools to study. Yarn is good, too, but its model is different from Racket's, so it's not really relevant.
U3SEVDPJT : thanks <@U07SJGB4H> and <@U07SCV14J> it's probably foolish of me to contemplate coming up with something that makes an impact but this is definitely a problem area that deserves a closer look.
U07SJGB4H : at the very least a tracking issue in the racket repo with some sort of plan and a breakdown of the work to do would be a big step forward
U3SEVDPJT : ha, <#C06V96CKX|general> anybody wants to join in?
U07SJGB4H : maybe after I finish working on stuff for racketcon :p
U3SEVDPJT : and a few other projects, or next year...
U07SCV14J : I'd be interested in working on it if I had about 40 more hours per week. ;)
U3SEVDPJT : more seriously, is the general management interested in entertaining a significant update to the package system? Or would we need to do some lobbying?
U3SEVDPJT : I do realize this likely may need changes to be made to DrRacket's package manager, and the package index site, so that'll be nontrivial to coordinate.
U07SJGB4H : the package site probably wouldn't _have_ to change to support this
U07SCV14J : The package server would. But not necessarily the frontend, I suppose.
U07SCV14J : I found the email thread from a little over a year ago between me, <@U3NJS8H7C>, and <@U0702F2CE>. Here's the bulk of what we concluded, as outlined by Matthew:```
* Change the information for a package in a catalog to include a
  version -&gt; source mapping.

  Concretely, this mapping could go under a `pkg-versions` key added
  to the current table. So, for backward compatibility, we still have
  the current information (for the latest version) as it's reported
  now. Also, package clients could continue to deal with catalogs that
  don;t include a `pkg-versions` entry.

  The version listed for a given source and checksum would be checked
  against the `version` declaration in a package's "info.rkt" file.
  The package manager would still only allow the installation of one
  checksum (as selected by version number, typically) per package.

* Change the catalog at <http://pkgs.racket-lang.org|pkgs.racket-lang.org> to accumulate a
  version-keyed mapping by noticing when, in the case of a Git-based
  source, a new checksum has a new version. When the version changes,
  the server can keep the previous version mapped to the previous
  checksum.

  For sources not based on Git, package authors would have to use some
  extra interface or tool to set a mapping. We'd want a `raco` tool
  for tasks like that. (It's strange to me that such a tool doesn't
  exist already.) The tool could also help authors using a Git repo
  update the package version number appropriately.

  If <http://pkgs.racket-lang.org|pkgs.racket-lang.org> missed a version due to a rapid sequence of
  version updates, if broken versions need to be removed, if a new
  revision for an old version needs to be introduced on a branch, etc.
  --- all of those would be possible manually. The automatic
  construction of the version table by <http://pkgs.racket-lang.org|pkgs.racket-lang.org> would just
  be a convenience for the common case and make it behave similar to
  the current system in those simple cases.

* Change the package-manager client to support the usual constraints
  on dependency versions. The package installation and update tools
  would have to solve those dependencies.

  The current `#:version` field in a dependency would be interpreted
  as allow &gt;= version and &lt;= the next major version (non-inclusive). A
  new keyword for a dependency would support more general constraints.

  [The "graphs" package declares a dependency on "base" version
   "5.3.2". That looks like the only package whose version dependency
   would need to be adjusted to fix this rule.]

  I imagine that `raco pkg update` should by default only update to a
  checksum for a version whose major number matches the current
  installation. Also, it should downgrade a package to solve
  constraints only if the user says that downgrades are ok.

  Right now, most dependency specifications are unversioned. I don't
  think it will work to assume "1.x", unless we add a special case for
  "base" to default to "6.x" and figure out something for "0.x".
  Unless we find something better, we'll end up allowing dependency
  specifications without a compatibility level, which is too bad.

  The dependency information currently provided by
  <http://pkgs.racket-lang.org|pkgs.racket-lang.org> is not precise enough to resolve dependencies
  --- it merges `deps` and `build-deps` --- but that should be easy
  to fix.

* A stack-like sequence of catalogs could provide a suitable set of
  default versions/checksums of packages (but, as always, that catalog
  can be overridden for a given package by specifying a non-catalog
  source) and serve as an archive of available packages.

* Tools like `raco pkg catalog-archive` could take a version
  constraint, which would typically be specified on "base", and solve
  constraints in the same way as installation.
```

U07SCV14J : There was a little more discussion after that, but that's close to what we generally ended up agreeing on. I don't think any of those changes would be especially controversial if someone went and implemented them, but that's no small feat.
U3SEVDPJT : that was very helpful, good to know how the others stand on it.
U3SEVDPJT : one relevant question here, are the current package tools designed to help end-users or developers? Should the tools attempt to help both audiences?
U3NJS8H7C : As long as someone follows that kind of plan – one that doesn't involve changing the way that module-name resolution works – then I think anyone could implement the changes. It's mostly a matter of updating the package client in "collects/pkg" (and tests and docs), the package-catalog server's implementation at <https://github.com/racket/pkg-index> , possibly the pkg-build service's implementation at <https://github.com/racket/pkg-build> , and the GUI package manager at <https://github.com/racket/gui-pkg-manager> .
Anything that changes the way module-name resolution works, in contrast, is almost certainly more trouble than you expect, even after I tell you that it's trouble.

U3SEVDPJT : <@U3NJS8H7C> thank you for the references to the repositories. I believe at this time the module-name resolution should be left alone. Modifying it in anyway would open a too big can of worms. I think the sensible approach at this time is to extend the current system in consecutive ways.
U462H29AR : <@U07SCV14J> I had to step away, and I'm catching up, and I think this thing you said is interesting for me:
&gt; We have a number of internal packages that break compatibility on a monthly basis, and that's okay, because we publish detailed changelogs and let people upgrade whenever they get the chance.

This is using the package manager in a way that hadn't really occurred to me. Here, "breaking changes" not only isn't bad, it's good -- because it means "people are making progress".

Whereas I've been thinking about the public package manager as a way for people/orgs to provide code for others to use. In which case, breaking changes is something I don't want to do to other people.  If I do it accidentally, I'll try to fix it quickly. And I'd like to depend on packages with a similar attitude.

So that's why I'm feeling, geez, this seems like a lot of work to support breaking changes, and instead why not try to encourage and help people not do that in the first place.  However, you're looking at it also from the point of view of using the package manager as part of in-house configuration management?

U3SEVDPJT : This gets at the distinction between regular end-users and developer users. The link referred to by <@U07SJGB4H> goes into the distinction in depth and is insightful about that difference.
U462H29AR : Ah OK ... will catch up more! :slightly_smiling_face:
U3NP867S6 : @lexi.lambda. @abmclin, @leif, <@U462H29AR>: I'm a bit late to the discussion, but this looks like it may lead to a good Racketeer Office Hours project in Seattle! :)


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
