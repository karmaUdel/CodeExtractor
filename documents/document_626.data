```
<@U17R26VR8> it’s a <http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#string> mapped to become a `Decoder ID`
<http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#map>
ah... map, yes ok :+2:
:two_thumbs_up:
:emote_fail:
but thank you
@fonf `&lt;$&gt;` is `fmap`. One is an infix operator, the other a prefix function, but they're literally the same function. They're good for different things, and they're both more general than `map` from `List`
my most ‘fun’ haskell operator adventure was finding an operator in a code example, I couldn’t find it in any of the imported libraries, looked it up on hoogle but none of those were it, I think I eventually found out it was in a language extension.
<@U6EAT2Z37>, I mean theres a package that has the `&lt;&lt;` and `&lt;|` operators
It exposes them.
And `&gt;&gt;` and `|&gt;` etc
I dont have a lot of Haskell experience. Their functionality it at least that of `$` and `.`, but maybe something else too, not sure.
Either way, the way I think of it, is that Elm is a subset of Haskell.
eh, Elm is its own thing. Nonstrict evaluation is at the heart of Haskell, and Elm is strict. Among ML families they're close in that they share syntax and the concept of managed side effects, but otherwise Elm is probably closer to Standard ML than Haskell. :smile: 
Ah, okay. Yeah Ive never used Standard ML
<@U0CL0AS3V> you think Elm is very different to Haskell? That's pretty interesting.
<@U153UK3FA> interestingly, there are two hoogles :slightly_smiling_face: sometimes I wish Elm had a hoogle, like how purescript does
<@U6EAT2Z37> Elm has <http://klaftertief.github.io/elm-search/>
Yeah, I think I saw that a while back. It's not very easy to find tho
I guess I can just google for "elm search" so that works :slightly_smiling_face: :+1:
<@U6EAT2Z37> The “Fancy Search” link in the resources section on <http://package.elm-lang.org> links to it.
TIL :slightly_smiling_face: Wouldn't have known that! :slightly_smiling_face: thanks
<@U6EAT2Z37> Different evaluation semantics and a different focus for the language means you end up with fairly different languages. They might look similar and there is a lot of conceptual overlap - they are, after, all, statically typed purely functional languages with similar syntax. Defining their relationship directly in terms of one another, though, is probably not very helpful. When it comes to language and library design, Elm is not (strictly) guided by Haskell, so defining one as a subset of the other is misguided at best.
People have tried to use Elm as "haskell for the web", and I don't think that has ever been a particularly nice experience
(aside: very nice to see you in here, I'm really enjoying your book!)
<@U3SJEDR96> Yeah, sure, they're different. Obviously. But they're **extremely** similar in many core ways. As you mention, algebraic data types, pure functions, lambda calculus base. I think there are more similarities than not. No one's trying to define Elm in terms of Haskell or vice versa. :slightly_smiling_face: It's just nice to compare them, when they're similar. Trying to compare JS and Elm would be... misguided... and understanding Haskell's managed effects gives a really nice insight into Elm's... (because Elm purposefully hides this away, mostly). I find it very fascinating, in general. Learning Haskell would *definitely* improve one's Elm, for example.
Yeah, I agree - purescript is more "Haskell for the web" :slightly_smiling_face: tho it's interestingly inbetween, too :slightly_smiling_face: (it's eager for a start... and uses `Eff` rather than a stack of effects, which is also interesting - tho Haskell has that, too, but it's not as popular)
Thanks for the book-compliment. I'd like to write one for Elm sometime
Very true! And of course, recognizing parallels and conceptual overlap deepens understanding. But recognizing the differences is harder than recognizing the similarities, especially for one who is new to either language; and therein lies a danger, too :slightly_smiling_face:
I realise there's a decided push towards "a language is a culture" in the Elm community. I'm not entirely sure I agree with that, but that's fine too :slightly_smiling_face:
<@U3SJEDR96> oh my gosh yes... I mean, that's one of the biggest reasons people coming from imperative langs find pure FP lambda calculus langs so difficult - they assume it's "execute every line from the top to the bottom" semantics... when it's not, it's "evaluate from this point out" semantics :slightly_smiling_face:
I think what _irks_ me about relating Elm and Haskell in public discussion is perhaps simply that learning a new language works best when _not_ trying to understand one in terms of another. The issue being that defining one in terms of another probably leads to trying to understand one in terms of the other.
Does that make sense?
Yeah it makes sense. I don't think I agree, though.
I think it's important to use what you have to learn faster than you could without it.
**use** imperative to understand functional, just don't use functional imperatively! :slightly_smiling_face:
*use* your understanding of OOP to see what pure FP is like... but don't try to do OOP in pure FP... :slightly_smiling_face:
It's a short term benefit; but it also means you have to unlearn some misguided inferred knowledge after a while.
the beauty of doing that is you start to understand more about the OOP you thought you understood and then realise "hey I didn't understand it as well as I thought" and you get a better grip of both :slightly_smiling_face:
I'm after non-confusion :slightly_smiling_face:
But yeah, comparison is not so useful... perhaps. Tho, lately I've been learning vim... and I don't have great answers to the semantic questions I had answers to in my existing editor... so that sucks a bit - that kind of comparison is *very* useful, I think.
I think that this type of drawing parallels and recognizing the massive conceptuals overlaps, is easier after you've grokked at least the basics of a language. Or at least, that has been my experience spending a ton of time in <#C192T0Q1E|beginners>. And I suppose learning is not a universal process :slightly_smiling_face:
Definitely.
Do we use classes and css files?
I want my styles to be scoped, is there a way to do it?
<@U6EAT2Z37> Forgive me my ignorance, but which book is it?
- using an existing framework in elm, like `elm-bootstrap` or `elm-tachyons`
Thanks. I will take a look
elm-css looks good. Scoping is my main issue
By style-elements do you mean similar to styled-components in react?
No, not really
<https://www.youtube.com/watch?v=NYb2GDWMIm0>
<@U1AP08WV6> <http://happylearnhaskelltutorial.com|happylearnhaskelltutorial.com> - no need to apologise :slightly_smiling_face:
<@U0EUHKVGB> hi! We were thinking in Gizra about creating an elm-all-set implementation (`type EverySet t = EveryDict t ())`) -- Just making sure it wasn't already done
There's an AllDict
But that's not what you mean is it? <http://package.elm-lang.org/packages/eeue56/elm-all-dict/2.0.1>
Sets are not Dicts, so I'm guessing not.
<@U6EAT2Z37> yeah I know -- I mean build and `EverySet` on top of it (`EveryDict` to `Dict` is what `EverySet` is to `Set`)
`type Set a = Set (Dict a ())` tho :slightly_smiling_face: (well, in Elm)
and yeah, Set in Elm is a Dict where key and value are the same
Isn't that really... inefficient / not so elegant?
<@U6EAT2Z37> great presentation about it by Robin -- <https://www.youtube.com/watch?v=mmiNobpx7eI>
<@U6EAT2Z37> it's not optimal; but neither is maintaining two rb-tree impementations ¯\_(?)_/¯
There was an old package for 0.15 which did that. However, the author stopped being active in Elm
Thank you :slightly_smiling_face:
<@U0GR72XH8> "where the value is `()`" rather, but let's chalk it up to a typo :slightly_smiling_face:
Didn't realise we'd switched to tries already. Always depends :slightly_smiling_face:
Yeah, there's no _typo_ safety in chats :wink:
Dict in Elm is just a red-black tree (although alternative implementations exist). Sets are Dicts "without" values. You get a constant memory overhead for every entry in a set, that way, but it's not _that_ bad, and hardly a problem in reality.
Be nicer if the RB tree was somehow exposed maybe? All good. Probably not possible.
Can't easily expose the constructors for pattern-matching without making it possible to build unbalanced trees, so the added complexity seems to outweigh the (limited) use that would have. People haven't  asked about breadth first traversal, so I doubt it would be of much practical use
Thank *you*!
does anyone have a link to Evans elm europe talk?
<@U37HUSJ4R> seems like it hasn’t been released yet, I saw somewhere that they’re close to putting in online
:smile: <@U2AHAPQUV>  thanks sir
any of you ever had trouble with WebSocket?
seems like one of my Elm web sockets is just not noticing messages
I have 3 of them
2 always get the messages
the other one is a mystery - I can configure things so it will see messages, but normally it misses them
and when I say "configure things", I mean "changing stuff on the server side"
it is totally irrational to me why it sometimes works and sometimes doesn't
and so, mine is a general question about known issues with WebSocket
I have tried setting up an identical socket in the javascript console of my browser and it sees the messages just fine
I believe I've solved the mystery
WebSocket.listen takes a string (the url) and a String -&gt; msg function
and my String -&gt; msg function was never returning a message
Elm exploded in the course of trying to decode the socket data.  Or such is my best guess.
if I just swap my decoding logic with a Result.Err, then I can see the socket messages getting processed
The functions are using the type List. Where does that type come from?
you will probably have better luck on the beginners channel
here in general I seem to be monologue-ing to myself
<@U5S1LBR7Y> :eyes:
<@U6EAT2Z37> Did I miss something?
Probably Native.List
No, that meant I was looking :slightly_smiling_face:
Okay
Not in Native.List
I mean it needs to be exposed if that was the case!
I *think* this is where list literals are defined: <https://github.com/elm-lang/elm-compiler/blob/master/src/Parse/Expression.hs#L81>
at least, the parsing of them
<@U5S1LBR7Y>: it's a compiler thing
Ohh Okay :thumbsup:
type List a = Cons a (List a) | Empty
You can check out my elm europe talk for more details in the implementation, if you're interested
Sure, I will. Thanks
:blush:
Also I am having a hard time understanding union types
Now I understand how it works
Mainly what I dont understand is where are the types inside the union types defined?
Not following :/
For eg: `type Maybe a = Nothing | Just a`
<@U0F01KLV6> I couldn't seem to see any implementation details in your talk
where is Nothing and Just defined
They are not strings so they need to be defined somewhere right?
<@U5S1LBR7Y> so that means `Maybe a` is a new type. It's defined as ... one of `Nothing` (as a data value constructor) or a data constructor value/function called `Just a` where a is some value of the same type as the `a` in `Maybe a`.
<@U6EAT2Z37> bad language, i ment explinaton on how they work "under the hood"
<@U5S1LBR7Y> do you understand what I just said?
<@U0F01KLV6> yeah, similarly. There was explanation of Linked List... maybe I didn't watch the correct talk. Didn't seem to be how it was actually implemented though.
<@U6EAT2Z37> So it is indeed defining three types?
`Maybe`, `Just` and `Nothing`?
<@U5S1LBR7Y> nope... just one type. the things on the right are the value constructors
a value constructor is a value or function that can build one of the values of that types
So... `type OneOrTwo = One | Two` can have exactly one of two different values.
`One : OneOrTwo` or `Two : OneOrTwo` &lt;- they're both values, but I've put the type on the end of them.
does that make sense?
<@U5S1LBR7Y>: one way to look at this, is that integers are essentially: type Int = 1 | 2 | 3 | 4... 
1 and 2 are values of the type Int
Ohh I get it now!
Yay :slightly_smiling_face:
Thanks <@U0F01KLV6> and <@U6EAT2Z37>
No problem
But if I create Such union types I will have to expose those value constructors as well right?
how would I do that?
You don't have to, no, but you can
I am guessing `module Foo exposing (OneOrTwo, One, Two)`
`exposing (OneOrTwo(..))`
You might hear "opaque types" bandied about. That's when you *don't* expose the "constructors".
It's often a good pattern to *not* expose them, but rather expose a function from the module. That way you can keep the implementation of the type private to the function, and it defines a very tight interface for your module.
So if you need to build a string value out of your `OneOrTwo` type, you could provide `toString : OneOrTwo -&gt; String`
Then you've decoupled your internals from your externals, and you're free to refactor the internals however you see fit, whenever you like. (It's a *lot* easier to refactor this way, I think)
Okay! Makes Sense :simple_smile:
Thanks
Just to understand, If I want to expose only `One`, i could write it like this: `exposing ( OneOrTwo(One) )`
Is that correct?
Try it out. :slightly_smiling_face: You'll have your answer :slightly_smiling_face:
<http://ellie-app.com|ellie-app.com>
Okay :laughing:
<https://ellie-app.com/3RBpDqTfrNDa1/0>
Cant find that option!
I don't know if you can.
I tried it locally!
It works as I thought, Now I get it!
Thank you for your time <@U6EAT2Z37>
just one file. i don't plan on adding a multiple files option, that's not really what ellie is for
hello - anyone know of a way to speed up elm compile times - currently it’s taking around 5 minutes which is pretty painful - I a stack of Mains and some common code - and then I elm-make all the mains and output the js for my app
I have about 500 modules and a few thousand elm files (including elm-stuff)
when the project was smaller compilation was fast - but now if I make a change to a common elm file which is used a lot - then it takes ages - and even if I make a change to a non common one - it still takes a lot longer than I would like
I think the main piece of advice is going to look for ways to cut down how many modules you're using and break up any very long case statements.
iirc, lots of small modules and very large case statements are especially rough on the compiler.
hmm - if I change the implementation of a function without changing the signature of the function - then do the callers of the function need to be recompiled? I think it should only need to be “relinked”
I think it’s the “linking” that takes time actually
really?
how come linking takes that long?
Well, that i cannot answer :slightly_smiling_face:
is there anyway to implement compilation fire walls ?
but it’s a lot of files to merge together
this compilation time is crippling!
indeed, 0.19 is supposed to make compilation faster though
500 modules sounds like a lot, i have like 20 modules or so, but then I put a lot in each file
Yah, the 0.19 speed bump should help, but I worry the 500+ modules is still going to be an issue if it continues to grow at that rate.
Whats the average LOC per file?
well using third party elm libs can bump up the number of modules as well
I don't know if those are counted/treated the same as local modules.
I don't know enough about the compiler to say either way confidently.
hmm
apparently the averge LOC is about 100
if you have any case statements with lots of possible cases, like `case (bigUnionType, anotherBigUnionType)`, those can especially slow down compilation
well don’t have too many of those really in the core code - not sure about 3rd party modules we use though
