```
Is this ok ?
quick question: is there named unpacking/pattern matching, like Haskell's `xs@(x:xss)`
<@U6GFNSEPR> yeah, it's "as" `(x::xss) as xs` in that case, IIRC
oh, excellent, thanks :slightly_smiling_face:
can't seem to manage to do it with a record though
<@U6GFNSEPR> `foo ({ bar, baz } as whatever) = ` should work
it does! I always forget the brackets
thank you very much, this makes some things nicely readable
on a related note, I noticed a bit of magic when you forget to name the record. in my `view : Model -&gt; Html Msg`, the compiler doesn't throw an error if I forget to name my argument `model`
so I can use `model`, even though I wrote `view { basePolygon, top, height } = '..`
no, you probably have a function `model : Model`
When using `beginnerProgram`, that is the exact reason I name it `initialModel` :slightly_smiling_face:
Yeah, it's a bit odd that it's `model` in `beginnerProgram`, but `init` in `program`
<@U24HQ3RJ7> Are you generating a stylesheet or using it inline?
`model` is just plain wrong naming, in my opinion
I think it's like that to match up with MV*.
ah yeah, it's a bit clearer to name it `initialModel`
<@U3SJEDR96> hmm,  do you mean `text` 's signature is *not* a free type variable?
No, it is. And that can be unified with `Never`. You could have `foo : Html Msg` and define `foo = text "hello"`, too. That would be completely valid. The type of the expression `text "hello"` is still `Html a`.
It's no more special than saying `foo : List String` with a definition of `foo = []`. That empty list doesn't really "hold" anything, so it could be a `List Never`, too, but since it has type `List a`, the compiler is fine with you saying it is a more specific thing than that, even though the implementation doesn't _need_ to be that constrainted
