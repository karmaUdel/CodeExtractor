U3NJS8H7C : <@U08JL5H89> I'm not sure what you mean, and I think that code is right. (It's the actual implementation in the simple case, as reflected by the `convert` helper function.) `malloc` does return a pointer, but the pointer refers to `from-type` content, where `from-type` isn't isn't necessarily a pointer type. Similarly, `pre-set!` and `ptr-ref` want a pointer to a `from-type`/`to-type` to cast between those.
U08JL5H89 : <@U3NJS8H7C> Ah, right, okay, that makes sense. Thanks.
U3PQ6GW3U : Which package provides `raco exe`?
U3PQ6GW3U : Answering my own question: `compiler-lib`
U0MAQ22G5 : trying to make my Racket macro-writing experience a bit saner. I'm defining a simple module lang and was hoping `(expand-module/step mod)` would let me expand modules that use DSLs, but getting an error, e.g.
test.rkt
```
#lang racket
(require macro-debugger/stepper)
(expand-module/step "./scratch.rkt")
```

scratch.rkt
```
#lang racket
(module test racket
  (let ([x 1] [y 2]) (or (even? x) (even? y))))

```
Produces:
&gt;derivation-parser: error on token #2: &lt;local-value, #&lt;syntax:/Users/ze/Code/racket/racket/share/pkgs/gui-lib/framework/private/sig.rkt:8:20 number-snip-class^&gt;&gt;

U0MAQ22G5 : A more general question is how do I debug my #lang DSLs? Say, I prepare a file in such a language as in ```
#lang rogue
(some rogue forms defined in ~/rogue/main.rkt)
```

Language is defined using syntax/module-reader and the collection is properly linked with `raco link rogue`, so Rogue script runs fine. How would go about stepping through its expansions steps? I'm trying to figure if I my transformations use bindings  i expect, e.g. the redefined #%app etc. Sadly, the above-mentioned `(expand-module/step mod)` didn't work for me out of the box. How do people debug such things?

U0MAQ22G5 : One more question is about redefining kernel forms like `#%app` and friends in my #lang implementation, something like this
rogue/main.rkt has
```
(provide #%datum
         #%top-interaction
         #%top
         (all-defined-out)
         (rename-out [app #%app]
                               [module-begin #%module-begin]))

(define-syntax (app stx)
      ... my implentation of #%app)

(define-simple-macro (some-rogue-form pattern)
    (f a)) ;; &lt;-- which binding of #%app will be used when this form is expanded inside a file written in #lang rogue? How do I confirm this using Racket tools?

(racket-module reader syntax/module-reader
  rogue)
```

U0MAQ22G5 : omg Macro Debugger tools are awesome!
U0MAQ22G5 : re the above #%app binding question syntax object browser in the stepper shows the binding comes from racket/base and not from my `(rename-out [app #%app])`, which is a bit confusing. I suspect I misunderstand scoping rules here, i.e. I expect #%app to be dynamically scope inside a file that uses my DSL `#lang rogue` when really macros defined in `rogue` end up expanding into forms that use lexically bound #%app, that is inside the module defining `rogue` the language. Could you guys correct my thinking here please?
U3NJS8H7C : The implicit `#%app` form in `(f a)` takes its context from the open parenthesis. (More precisely, `(f a)` is a syntax list and there's a context attached to the list as a whole, in addition to contexts on the individual `f` and `a` tokens.) Since the `#%app` in the environment of `(f a)` is the one from `racket/base`, that's the one used when `(f a)` is treated as `(#%app f a)`.
U0MAQ22G5 : ah I think I get it. I'm beginning to wonder how we ever managed to redefine kernel forms like #%app and #%module-begin then. I've seen things like this being used
```
(provide (except-out (all-from-out racket)
                     lambda
                     ?
                     define
                     eval
                     require
                     modulo
                     remainder
                     /
                     #%app)
         (rename-out [new-lambda lambda]
                     [new-lambda ?]
                     [new-define define]
                     [divide /]
                     [myapp #%app]
                     ))
```

U3NJS8H7C : When `new-lambda` is used as `lambda` in some importing module, the expressions written inside that `lambda` will also be from the importing module – and so an open parentheses there will see `myapp` instead of `#%app` from `racket/base`. You may be thinking that the body of a`new-lambda` use is treated as being from the `new-lambda` place, but it's not; the body is treated as being from wherever it is written (i.e., lexical scope).
U0MAQ22G5 : thank you Matthew! that really helps
U0MAQ22G5 : ok, now  i need to think a bit harder about what I'm trying to do here
U0MAQ22G5 : fwiw I'm just amazed at how much introspection macro-debugger/stepper offers. Like I'm no longer blind
U08JL5H89 : <@U3NJS8H7C> Just a sanity check, environment variables that are set using `putenv` are also going to be set in FFI calls, correct?
U08JL5H89 : Oh wait, no, it uses current-environment-variables, never mind.
U3NJS8H7C : If `(current-environment-variables)` returns its original value, then `putenv` affects OS-level environment variables
U08JL5H89 : That makes sense. Thanks.
U08JL5H89 : So basically don't change the parameter and it works. Thanks. :slightly_smiling_face:
U07SJGB4H : <@U3VGR2S7Q> <@U3QF0EM0E> do either of you have more comments on <https://github.com/racket/rackunit/pull/59> ?
U08JL5H89 : Does anyone know how to be more specific when requesting an opengl context than just core/compatibility?
U08JL5H89 : Namely, I want core3.3
U08JL5H89 : If I can get it anyway.
U08JL5H89 : <http://docs.racket-lang.org/draw/gl-config_.html?q=gl-config>
U08JL5H89 : <@U0G0JDQGZ> You might now?
U08JL5H89 : hmm…looks like not. At least not yet. :slightly_smiling_face:
U08JL5H89 : It looks like when you request core, it starts at 4.x and goes down to 3.0
U08JL5H89 : WAIT!!! No. Grr….despite asking for a core context, its still giving me a legacy one. That absolutely should be in the docs.
U08JL5H89 : That, and you should absolutely be able to find out what kind of context you got after the fact.
U08JL5H89 : Hmm…I guess in get-legacy? it says that it is only supported on mac 10.7+ and _some_ linux variants.
U08JL5H89 : But there still doesn't seem to be a way to check which version you ended up getting once you go it.
U3NJS8H7C : <@U08JL5H89> I'm no GL expert, but I thought there were GL-level functions that will tell you
U08JL5H89 : There are some.
U08JL5H89 : Namely, glGetString
U08JL5H89 : <@U3NJS8H7C> Btw, its the line `(force lazy-GLX_ARB_create_context?)` that is causing it to create a compatibility context.
U08JL5H89 : When I comment out that line a compatibility context gets created. (Version 3.3)
U3NJS8H7C : You get a *non-*compatibility context when it's commented out? Neil wrote that code, and I don't know the right answer in this case, but I'm happy to accept patches from people who do.
U0G0JDQGZ : leif: it is not common for OpenGL apis to give you the ability to ask for a specific version, because drivers typically don't support multiple options anyways. OpenGL versions never change the meaning of old stuff (i.e. it is forward compatible) and when you write GLSL you have to specify the version always... so what exactly is the problem that yo
U0G0JDQGZ : u are trying to solve?
U08JL5H89 : I mean, newer versions _do_ remove deprecated stuff. Although the only instance I can think of this happening in a major way was 3.0 to 3.1
U08JL5H89 : I have a GLSL shader, it is not doing anything fancy, just drawing a quad to the screen, and drawing a texture to that quad.
U08JL5H89 : (aka, its a media player)
U08JL5H89 : The shader is written in GLSL 330
U08JL5H89 : On my mac, I get 3.3 when I ask for the core profile.
U08JL5H89 : But on linux, despite asking for core, I got compatibility. Which corresponded to version OpenGL 3.0, so GLSL 130.
U08JL5H89 : <@U0G0JDQGZ> ^
U08JL5H89 : Oh, also, glx (which is what the linux opengl bindings use), does let you request a specific version. Of course you are limited to what your hardware can support. :slightly_smiling_face:
U08JL5H89 : <@U3NJS8H7C> Kind of. When you request a core profile, Racket's opengl library tries a few tests to see if its compatible. If it is, and you requested a core profile, it gives you a context using the core profile. However, if it can't, it ignores what you requested and silently gives you  a compatibility context.
U08JL5H89 : The only real way to test after the fact (as far as I can tell), which one you got is using the glGetString function and checking your opengl version.
U08JL5H89 : Anyway, I commented out one of the checks that was failing, to see what would happen, and the opengl context worked just fine. Which makes me think we are potentially checking more stuff than we need to.
U08JL5H89 : (Obviously I haven't tested that thoroughly yet.)
U08JL5H89 : Anyway, thanks.
U0G0JDQGZ : leif: 3.0 to later is basically a totally new API, which what the whole core vs compatibility thing is about
U0G0JDQGZ : it sounds like either something wrong with Racket checking of the version (which you said) or your driver doesn't really support new stuff, which is common on Linux software implementations
U08JL5H89 : <@U0G0JDQGZ> yup. Or at least thats when they dropped the fixed pipeline in favor of the shaders from opengl 2. But how would I test if it doesn't ‘really' support newer stuff?
U08JL5H89 : Like, I'm able to open up a window, and build and run a GLSL 330 program.
U086VDRBK : Apropos OpenGL and shaders: Is it possible to get GLSL version 130 version on mac? If not, how do I get a newer version?
U086VDRBK : (I can't get Ruckus to run mac)
U086VDRBK : To see which versions of GLSL that were supported I tried different values for the version in: <https://github.com/cbiffle/ruckus/blob/master/viz/preamble.glsl>
U086VDRBK : Version 120 seems to exist - but the preamble uses more recent features.
U044HMK7S : yo
U044HMK7S : hey!
U044GA9BR : morning
U044HMK7S : <@U044GA9BR>: you're a full day ahead of me almost haha
U044G404Z : morning... i am going to bed and he says morning... its so frustrating
U044G404Z : had the same thought <@U044HMK7S>
U044HMK7S : <@U044G404Z>: i know its crazy
U044G404Z : some atom users here?
U044JU5CA : #vim4lyfe
U044JU5CA : Has anyone used `react-router` with ES6 classes in 0.13
U044HMK7S : <@U044JU5CA>: not yet
U044HMK7S : i like vim but not as my full time editor
U044HMK7S : I really need to write a newsletter. It's up to 450 subscribers and I haven't sent anything in a while.
U044G404Z : <@U044JU5CA>: <https://github.com/pheuter/essential-react/tree/master/src/routers>
U044G404Z : a react starter kit, very minimal and they use react-router with es6 classes
U044JU5CA : Nice. My main problem with it is that I think putting the router object on `this.context` feels strange and awkward
U044JU5CA : and you need to define `Foo.contextTypes` everywhere as well
U044HMK7S : <@U044JU5CA>: I use a flux implementation that passes a flux object through the context and I'm actually really liking it
U044JU5CA : do you need to use contextTypes with that?
U044HMK7S : yeah, for anything with context you do, that's the only annoying part
U044JU5CA : and in ES6 classes it seems you can only write them after you've defined your class
U044JU5CA : ```
U044JU5CA : ```class Foo extends React.Component {
  render () {
   &lt;span&gt;Foo&lt;/span&gt;
  }
}

Foo.contextTypes = {
  router: React.PropTypes.func.isRequired
}
```

U044HMK7S : create a text snippet
U044G404Z : yeah context is still not final in react.js. i dont like context but who cares what i like :wink:
U044JU5CA : it'd be fine if I didn't have to write contextTypes like that
U044JU5CA : messes up the cleanness of writing `export default class Foo extends React.Component {`
U044HMK7S : I've used context for a year now :wink: and i prefer react.createclass still because of a couple of these problems...
U044JU5CA : this.context.hipster
U044JU5CA : :stuck_out_tongue:
U044JU5CA : yeah I guess maybe I should stick to createClass for now


in above conversation, code/s mentioned has issue/s?
	If Yes:
	1.Bad	2.Very bad
	If No:
	1.Good	2.Very good


How confident are you?
	1.Low
	2.Average
	3.High

Optional!
can you highlight place/word/sentence which lead to your decision
