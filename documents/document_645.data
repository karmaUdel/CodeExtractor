```
How function application is actually implemented? I'm still in researching phase now - so any hint is  a good one - not looking for a full blown explanation - just some point were to start wrapping my head around this :simple_smile:
Sure, there's a way to see the 5. Just call `add 0` and you'll get `5`.
I haven't seen the implementation code, but I'll bet function application in Elm is just implemented as function application in JavaScript.
:smile:  that's a nice trick :smile: No i'm loking for a way to see inside partially applied functions in general. that only works will add 5 not with `Maybe.withDefault (SomeComplexDecoderwarped as maybe)`
No, there's no way to do it in general. Closures are, well, closed.
That is, function values
If you want to "see inside", then you should represent it with a custom data type instead of a function.
just to give you some context. I'm buliding a new elm debugger - i call it the x-ray debugger - and it'a all about seeing the computation pipeline. And for normal functions will work. Not 100% sure but pretty sure i can make it do what i want - but i'm stuck on this partially applied ones. No idea what to do. That `5` is stored somwere. Just need a good way to see it/grab it - even if it's not just in elm - meta elm/ JavaScript - or something.  I don't expect facts here - this is a unusual request - but just your thoughts on this issue.
It's possible the 5 is just some jitted V8 code that is now assembly instructions somewhere.
How would it work for normal functions?
Hey, trying to figure out what `elm-test --watch` uses for monitoring disk changes, because it’s burning up my CPU. I’m guessing `chokidar`, but I’m not seeing a `package.json` in the repo and I’m not sure where to look.
I guess the 5 is in the environment part of the closure in the JS.
:grin: that sounds.. :grin: Anyway we'l see in the worst case i will just provide arguments for the normal functions and use &lt;function&gt; as the debugger does it for what it can't evaluate.
If you analyze the original code, you could transform it to store the arguments somewhere where you can get at them later.
Kind of dissapoinging but good enough for the first stage.
when saving and compiling code - you don't see the same CPU spikes? It's only happening with `elm-test`?
Hey, sorry, didn’t see this until just now, let me czech…
Yeah, I mean, I can run `elm-make` on its own, but it’s barely a blip on the radar, whereas `elm-test --watch` runs at a constant 110-150% CPU even when idling.
maybe we *should* be using chokidar :smile:
mind opening an issue on <https://github.com/rtfeldman/node-test-runner/issues> ?
ideally with system info and something small that reproduces it
